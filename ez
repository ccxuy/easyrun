#!/usr/bin/env bash
#
# EZ - go-task 智能前端
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/ez-core.sh"

# -----------------------------------------------------------------------------
# 命令: version
# -----------------------------------------------------------------------------
cmd_version() {
    echo "ez version $EZ_VERSION"
    echo ""
    echo "Dependencies:"
    echo "  yq:   $("$YQ" --version 2>/dev/null | head -1)"
    echo "  task: $("$TASK" --version 2>/dev/null | head -1)"
}

# -----------------------------------------------------------------------------
# 命令: help
# -----------------------------------------------------------------------------
cmd_help() {
    cat << 'EOF'
EZ - go-task 任务编排前端

用法: ez [命令] [选项]

任务执行:
    ez                    列出所有任务
    ez <name>             执行任务 (= ez run <name>)
    ez <name> --dry-run   预览命令

任务管理:
    new <name>            创建文件夹任务 (tasks/<name>/)
    show <name>           查看任务详情和参数
    export / import       导出/导入文件夹任务
    check [name]          验证语法
    clean <name|--all>    清理运行时数据

计划编排:
    plan <name>           执行计划 (= plan run <name>)
    plan list / new / show / build / check
                          计划管理子命令

工具:
    browse                交互式任务浏览
    log list / show       执行日志
    completion bash|zsh   Tab 补全

选项:
    --dry-run             预览不执行
    --log                 记录日志
    --workspace=<name>    隔离执行 (auto = 自动命名)
    --no-workspace        源目录执行

ez version              版本信息
ez help                 本帮助

分布式 (可选): ez server help / ez client help
EOF
}

# -----------------------------------------------------------------------------
# 命令: log
# -----------------------------------------------------------------------------
cmd_log_list() {
    local count="${1:-20}"
    list_recent_logs "$count"
}

cmd_log_show() {
    local pattern="${1:-}"
    [[ -z "$pattern" ]] && die "用法: ez log show <pattern>"
    show_log "$pattern"
}

cmd_log_clean() {
    local days="${1:-7}"
    init_log_dir
    find "$EZ_LOG_DIR" -name "*.log" -mtime +"$days" -delete
    echo -e "${GREEN}✓ 已清理 $days 天前的日志${NC}"
}

cmd_log() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)  cmd_log_list "$@" ;;
        show)     cmd_log_show "$@" ;;
        clean)    cmd_log_clean "$@" ;;
        *)        die "未知 log 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# 命令: list
# -----------------------------------------------------------------------------
cmd_list() {
    local taskfile filter="" show_all=false group_mode=true
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--all) show_all=true; shift ;;
            -f|--flat) group_mode=false; shift ;;
            -g|--grep) filter="$2"; shift 2 ;;
            *) filter="$1"; shift ;;
        esac
    done

    local tasks
    tasks=$(get_tasks "$taskfile")

    # 收集根 Taskfile 任务
    local visible_tasks=()
    local task_sources=()  # 标记来源: "" = 根, "[folder]" = 文件夹任务
    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        if [[ "$name" == _* ]] && ! $show_all; then
            continue
        fi
        if [[ -n "$filter" ]] && [[ "$name" != *"$filter"* ]]; then
            continue
        fi
        visible_tasks+=("$name")
        task_sources+=("")
    done <<< "$tasks"

    # 收集文件夹任务 (tasks/ 目录)
    if [[ -d "$EZ_TASKS_DIR" ]]; then
        while IFS= read -r name; do
            [[ -z "$name" ]] && continue
            if [[ -n "$filter" ]] && [[ "$name" != *"$filter"* ]]; then
                continue
            fi
            # 避免与根 Taskfile 中的同名任务重复
            local dup=false
            for vt in "${visible_tasks[@]}"; do
                [[ "$vt" == "$name" ]] && dup=true && break
            done
            if ! $dup; then
                visible_tasks+=("$name")
                task_sources+=("[folder]")
            fi
        done < <(get_folder_tasks)
    fi

    local total=${#visible_tasks[@]}

    if [[ $total -eq 0 ]]; then
        echo "  (无任务)"
        return
    fi

    # 如果任务数量少于 15 或指定 --flat，直接列表显示
    if [[ $total -lt 15 ]] || ! $group_mode; then
        echo -e "${BOLD}Tasks:${NC} ($total tasks)"
        echo ""
        for ((idx=0; idx<total; idx++)); do
            local name="${visible_tasks[$idx]}"
            local source="${task_sources[$idx]}"
            local desc="" flags=""

            if [[ "$source" == "[folder]" ]]; then
                # 文件夹任务：从 tasks/ 子目录 Taskfile 读取描述
                local ftfile="$EZ_TASKS_DIR/$name/Taskfile.yml"
                desc=$(get_task_prop "$ftfile" "default" "desc" 2>/dev/null || true)
                flags=" ${MAGENTA}[folder]${NC}"
            else
                desc=$(get_task_prop "$taskfile" "$name" "desc")
                has_ez_params "$taskfile" "$name" && flags+=" ${CYAN}[params]${NC}"
                has_ez_extends "$taskfile" "$name" && flags+=" ${YELLOW}[extends]${NC}"
                has_ez_compose "$taskfile" "$name" && flags+=" ${BLUE}[compose]${NC}"
            fi

            printf "  ${GREEN}%-25s${NC} %s%s\n" "$name" "$desc" "$flags"
        done
        return
    fi

    # 分组显示模式
    echo -e "${BOLD}Tasks:${NC} ($total tasks)"
    echo -e "${DIM}提示: 使用 'ez list <keyword>' 过滤, 'ez list -f' 平铺显示${NC}"
    echo ""

    # 按前缀分组
    declare -A groups
    declare -A group_sources
    declare -a no_prefix
    declare -a no_prefix_sources
    for ((idx=0; idx<total; idx++)); do
        local name="${visible_tasks[$idx]}"
        local source="${task_sources[$idx]}"
        if [[ "$name" == *-* ]]; then
            local prefix="${name%%-*}"
            groups["$prefix"]+="$name "
            group_sources["${prefix}_${name}"]="$source"
        else
            no_prefix+=("$name")
            no_prefix_sources+=("$source")
        fi
    done

    # 显示无前缀的任务
    if [[ ${#no_prefix[@]} -gt 0 ]]; then
        echo -e "${BOLD}General:${NC}"
        for ((idx=0; idx<${#no_prefix[@]}; idx++)); do
            local name="${no_prefix[$idx]}"
            local source="${no_prefix_sources[$idx]}"
            local desc=""
            local flags=""
            if [[ "$source" == "[folder]" ]]; then
                local ftfile="$EZ_TASKS_DIR/$name/Taskfile.yml"
                desc=$(get_task_prop "$ftfile" "default" "desc" 2>/dev/null || true)
                flags=" ${MAGENTA}[folder]${NC}"
            else
                desc=$(get_task_prop "$taskfile" "$name" "desc")
            fi
            printf "  ${GREEN}%-25s${NC} %s%s\n" "$name" "$desc" "$flags"
        done
        echo ""
    fi

    # 显示分组
    for prefix in $(echo "${!groups[@]}" | tr ' ' '\n' | sort); do
        local group_tasks=(${groups[$prefix]})
        local count=${#group_tasks[@]}
        echo -e "${BOLD}${prefix}-*${NC} ${DIM}($count tasks)${NC}"

        local shown=0
        for name in "${group_tasks[@]}"; do
            if [[ $shown -lt 3 ]]; then
                local source="${group_sources["${prefix}_${name}"]}"
                local desc="" flags=""
                if [[ "$source" == "[folder]" ]]; then
                    local ftfile="$EZ_TASKS_DIR/$name/Taskfile.yml"
                    desc=$(get_task_prop "$ftfile" "default" "desc" 2>/dev/null || true)
                    flags=" ${MAGENTA}[folder]${NC}"
                else
                    desc=$(get_task_prop "$taskfile" "$name" "desc")
                fi
                printf "  ${GREEN}%-25s${NC} %s%s\n" "$name" "$desc" "$flags"
            fi
            ((shown++))
        done
        if [[ $count -gt 3 ]]; then
            echo -e "  ${DIM}... 还有 $((count-3)) 个任务 (ez list $prefix)${NC}"
        fi
        echo ""
    done
}

# -----------------------------------------------------------------------------
# 命令: browse (交互式任务浏览器)
# -----------------------------------------------------------------------------
cmd_browse() {
    local taskfile filter=""
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 可选搜索过滤
    [[ $# -gt 0 ]] && filter="$1"

    # 获取任务列表
    local tasks=()
    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        [[ "$name" == _* ]] && continue
        if [[ -n "$filter" ]] && [[ "$name" != *"$filter"* ]]; then
            continue
        fi
        tasks+=("$name")
    done < <(get_tasks "$taskfile")

    if [[ ${#tasks[@]} -eq 0 ]]; then
        echo "未找到任务"
        return 1
    fi

    local selected=0
    local expanded=""
    local show_related=false

    # 主循环
    while true; do
        clear
        echo -e "${BOLD}EZ Task Browser${NC} (↑↓ 导航, Enter 展开, r 运行, d dry-run, s 详情, q 退出)"
        echo ""

        local i=0
        for name in "${tasks[@]}"; do
            local prefix="  "
            [[ $i -eq $selected ]] && prefix="${GREEN}▶ ${NC}"

            # 获取任务标记
            local flags=""
            has_ez_params "$taskfile" "$name" && flags+="${CYAN}P${NC}"
            has_ez_extends "$taskfile" "$name" && flags+="${YELLOW}E${NC}"
            has_ez_compose "$taskfile" "$name" && flags+="${BLUE}C${NC}"
            has_ez_remote "$taskfile" "$name" && flags+="${MAGENTA}R${NC}"
            has_ez_artifacts "$taskfile" "$name" && flags+="${GREEN}A${NC}"

            local desc
            desc=$(get_task_prop "$taskfile" "$name" "desc")

            if [[ -n "$flags" ]]; then
                printf "%s%-25s ${DIM}%s${NC} [%s]\n" "$prefix" "$name" "$desc" "$flags"
            else
                printf "%s%-25s ${DIM}%s${NC}\n" "$prefix" "$name" "$desc"
            fi

            # 如果此任务被展开，显示关联任务
            if [[ "$expanded" == "$name" ]] && $show_related; then
                # 依赖任务
                local deps
                deps=$(get_task_deps "$taskfile" "$name")
                if [[ -n "$deps" ]]; then
                    echo -e "    ${DIM}└─ deps:${NC}"
                    while IFS= read -r dep; do
                        [[ -n "$dep" ]] && echo "       → $dep"
                    done <<< "$deps"
                fi

                # 继承自
                if has_ez_extends "$taskfile" "$name"; then
                    local base
                    base=$(get_ez_extends "$taskfile" "$name")
                    echo -e "    ${DIM}└─ extends:${NC} $base"
                fi

                # 组合任务
                if has_ez_compose "$taskfile" "$name"; then
                    echo -e "    ${DIM}└─ compose:${NC}"
                    local compose_json
                    compose_json=$(get_ez_compose_json "$taskfile" "$name")
                    local cc
                    cc=$(echo "$compose_json" | "$YQ" eval 'length' -)
                    for ((j=0; j<cc; j++)); do
                        local ct
                        ct=$(echo "$compose_json" | "$YQ" eval ".[$j].task" -)
                        echo "       $((j+1)). $ct"
                    done
                fi

                # 远程配置
                if has_ez_remote "$taskfile" "$name"; then
                    local nodes
                    nodes=$(get_ez_remote_nodes "$taskfile" "$name")
                    echo -e "    ${DIM}└─ remote:${NC} $nodes"
                fi
            fi

            ((i++))
        done

        echo ""
        echo -e "${DIM}P=params E=extends C=compose R=remote A=artifacts${NC}"

        # 读取按键
        read -rsn1 key
        case "$key" in
            A|B|C|D)
                # 方向键 (需要额外读取)
                read -rsn2 -t 0.1 extra
                case "$extra" in
                    "[A") ((selected > 0)) && ((selected--)) ;;
                    "[B") ((selected < ${#tasks[@]}-1)) && ((selected++)) ;;
                esac
                ;;
            $'\x1b')
                # ESC 序列
                read -rsn2 -t 0.1 extra
                case "$extra" in
                    "[A") ((selected > 0)) && ((selected--)) ;;
                    "[B") ((selected < ${#tasks[@]}-1)) && ((selected++)) ;;
                esac
                ;;
            "")
                # Enter - 切换展开
                local current="${tasks[$selected]}"
                if [[ "$expanded" == "$current" ]]; then
                    show_related=false
                    expanded=""
                else
                    expanded="$current"
                    show_related=true
                fi
                ;;
            r|R)
                # 运行任务
                clear
                cmd_run "${tasks[$selected]}"
                echo ""
                read -rp "按 Enter 继续..." </dev/tty
                ;;
            d|D)
                # Dry-run
                clear
                cmd_run "${tasks[$selected]}" --dry-run
                echo ""
                read -rp "按 Enter 继续..." </dev/tty
                ;;
            s|S)
                # 显示详情
                clear
                cmd_show "${tasks[$selected]}"
                echo ""
                read -rp "按 Enter 继续..." </dev/tty
                ;;
            q|Q)
                clear
                return 0
                ;;
        esac
    done
}

# -----------------------------------------------------------------------------
# 命令: show
# -----------------------------------------------------------------------------
cmd_show() {
    local task="${1:-}"
    [[ -z "$task" ]] && die "用法: ez show <task>"

    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 检查是否是文件夹任务
    if is_folder_task "$task"; then
        local task_dir="$EZ_TASKS_DIR/$task"
        local ftfile="$task_dir/Taskfile.yml"
        echo -e "${BOLD}Task: ${GREEN}$task${NC} ${MAGENTA}[folder]${NC}"
        echo ""
        echo -e "${BOLD}Directory:${NC} $task_dir/"
        echo ""

        # 显示 task.yml 元数据 (如果存在)
        if [[ -f "$task_dir/task.yml" ]]; then
            echo -e "${BOLD}Metadata (task.yml):${NC}"
            local task_desc task_usage
            task_desc=$("$YQ" eval '.desc // ""' "$task_dir/task.yml" 2>/dev/null)
            task_usage=$("$YQ" eval '.usage // ""' "$task_dir/task.yml" 2>/dev/null)
            [[ -n "$task_desc" && "$task_desc" != "null" ]] && echo "  desc: $task_desc"
            [[ -n "$task_usage" && "$task_usage" != "null" ]] && echo "  usage: $task_usage"

            local tags
            tags=$("$YQ" eval '.tags // [] | join(", ")' "$task_dir/task.yml" 2>/dev/null)
            [[ -n "$tags" && "$tags" != "null" ]] && echo "  tags: $tags"
            echo ""
        fi

        local desc
        desc=$(get_task_prop "$ftfile" "default" "desc" 2>/dev/null || true)
        [[ -n "$desc" ]] && echo -e "${BOLD}Description:${NC} $desc" && echo ""

        echo -e "${BOLD}Commands:${NC}"
        "$YQ" eval '.tasks.default.cmds[].cmd // .tasks.default.cmds[]' "$ftfile" 2>/dev/null | while IFS= read -r cmd; do
            [[ -n "$cmd" ]] && echo "  - $cmd"
        done
        echo ""

        # 显示目录内容
        echo -e "${BOLD}Files:${NC}"
        ls -1 "$task_dir" | while read -r f; do
            echo "  $f"
        done
        return
    fi

    # 检查任务是否存在
    local exists
    exists=$("$YQ" eval ".tasks.\"$task\" // \"\"" "$taskfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "任务未找到: $task"

    echo -e "${BOLD}Task: ${GREEN}$task${NC}"
    echo ""

    # 描述
    local desc
    desc=$(get_task_prop "$taskfile" "$task" "desc")
    [[ -n "$desc" ]] && echo -e "${BOLD}Description:${NC} $desc" && echo ""

    # 继承信息
    if has_ez_extends "$taskfile" "$task"; then
        local base_task
        base_task=$(get_ez_extends "$taskfile" "$task")
        echo -e "${BOLD}Extends:${NC} ${YELLOW}$base_task${NC}"

        # 显示覆盖的默认值
        local defaults_json
        defaults_json=$(get_ez_defaults_json "$taskfile" "$task")
        if [[ "$defaults_json" != "{}" && "$defaults_json" != "null" ]]; then
            echo -e "${BOLD}Defaults Override:${NC}"
            echo "$defaults_json" | "$YQ" eval 'to_entries | .[] | "  " + .key + ": " + .value' -
        fi
        echo ""
    fi

    # 组合信息
    if has_ez_compose "$taskfile" "$task"; then
        echo -e "${BOLD}Composed Tasks:${NC}"
        local compose_json
        compose_json=$(get_ez_compose_json "$taskfile" "$task")
        local compose_count
        compose_count=$(echo "$compose_json" | "$YQ" eval 'length' -)
        for ((i=0; i<compose_count; i++)); do
            local ctask cdefaults
            ctask=$(echo "$compose_json" | "$YQ" eval ".[$i].task" -)
            cdefaults=$(echo "$compose_json" | "$YQ" eval -o=json ".[$i].defaults // {}" -)
            local step_num=$((i+1))
            echo -e "  ${CYAN}$step_num. $ctask${NC}"
            if [[ "$cdefaults" != "{}" && "$cdefaults" != "null" ]]; then
                echo "$cdefaults" | "$YQ" eval 'to_entries | .[] | "     " + .key + ": " + .value' -
            fi
        done
        echo ""
    fi

    # 日志配置
    if has_ez_log "$taskfile" "$task"; then
        local log_dir log_prefix
        log_dir=$(get_ez_log_dir "$taskfile" "$task")
        log_prefix=$(get_ez_log_prefix "$taskfile" "$task")
        echo -e "${BOLD}Log Config:${NC}"
        echo -e "  Dir:    ${DIM}$log_dir${NC}"
        echo -e "  Prefix: ${DIM}$log_prefix${NC}"
        echo ""
    fi

    # 远程执行配置
    if has_ez_remote "$taskfile" "$task"; then
        echo -e "${BOLD}Remote Execution:${NC}"
        local remote_json
        remote_json=$(get_ez_remote_json "$taskfile" "$task")
        local nodes
        nodes=$(echo "$remote_json" | "$YQ" eval '.nodes | join(", ") // ""' - 2>/dev/null || true)
        [[ -n "$nodes" && "$nodes" != "null" ]] && echo -e "  Nodes:    ${MAGENTA}$nodes${NC}"
        local sync_in
        sync_in=$(echo "$remote_json" | "$YQ" eval '.sync_in | join(", ") // ""' - 2>/dev/null || true)
        [[ -n "$sync_in" && "$sync_in" != "null" ]] && echo -e "  Sync In:  ${DIM}$sync_in${NC}"
        local sync_out
        sync_out=$(echo "$remote_json" | "$YQ" eval '.sync_out | join(", ") // ""' - 2>/dev/null || true)
        [[ -n "$sync_out" && "$sync_out" != "null" ]] && echo -e "  Sync Out: ${DIM}$sync_out${NC}"
        local workdir
        workdir=$(echo "$remote_json" | "$YQ" eval '.workdir // ""' - 2>/dev/null || true)
        [[ -n "$workdir" && "$workdir" != "null" ]] && echo -e "  Workdir:  ${DIM}$workdir${NC}"
        echo ""
    fi

    # 产物定义
    if has_ez_artifacts "$taskfile" "$task"; then
        echo -e "${BOLD}Artifacts:${NC}"
        local artifacts_json
        artifacts_json=$(get_ez_artifacts_json "$taskfile" "$task")
        echo "$artifacts_json" | "$YQ" eval 'to_entries | .[] | "  " + .key + ": " + .value.path + " (" + (.value.desc // "no desc") + ")"' - 2>/dev/null
        echo ""
    fi

    # 输入依赖
    if has_ez_inputs "$taskfile" "$task"; then
        echo -e "${BOLD}Inputs:${NC}"
        local inputs_json
        inputs_json=$(get_ez_inputs_json "$taskfile" "$task")
        local input_count
        input_count=$(echo "$inputs_json" | "$YQ" eval 'length' -)
        for ((i=0; i<input_count; i++)); do
            local artifact from to
            artifact=$(echo "$inputs_json" | "$YQ" eval ".[$i].artifact" -)
            from=$(echo "$inputs_json" | "$YQ" eval ".[$i].from" -)
            to=$(echo "$inputs_json" | "$YQ" eval ".[$i].to // \"./\"" -)
            echo -e "  ${CYAN}$artifact${NC} from ${GREEN}$from${NC} → $to"
        done
        echo ""
    fi

    # 命令 (考虑继承)
    echo -e "${BOLD}Commands:${NC}"
    if has_ez_extends "$taskfile" "$task"; then
        local base_task
        base_task=$(get_ez_extends "$taskfile" "$task")
        echo -e "  ${DIM}(inherited from $base_task)${NC}"
        "$YQ" eval ".tasks.\"$base_task\".cmds[].cmd // .tasks.\"$base_task\".cmds[]" "$taskfile" 2>/dev/null | while IFS= read -r cmd; do
            [[ -n "$cmd" ]] && echo "  - $cmd"
        done
    elif ! has_ez_compose "$taskfile" "$task"; then
        "$YQ" eval ".tasks.\"$task\".cmds[].cmd // .tasks.\"$task\".cmds[]" "$taskfile" 2>/dev/null | while IFS= read -r cmd; do
            [[ -n "$cmd" ]] && echo "  - $cmd"
        done
    else
        echo -e "  ${DIM}(see composed tasks above)${NC}"
    fi
    echo ""

    # EZ 参数 (考虑继承)
    local params_json=""
    if has_ez_extends "$taskfile" "$task"; then
        params_json=$(resolve_inherited_params "$taskfile" "$task")
    elif has_ez_params "$taskfile" "$task"; then
        params_json=$(get_ez_params_json "$taskfile" "$task")
    fi

    if [[ -n "$params_json" && "$params_json" != "[]" && "$params_json" != "null" ]]; then
        echo -e "${BOLD}Parameters:${NC}"
        local count
        count=$(echo "$params_json" | "$YQ" eval 'length' -)

        for ((i=0; i<count; i++)); do
            local pname ptype pdefault phelp poptions query_cmd query_url
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            ptype=$(echo "$params_json" | "$YQ" eval ".[$i].type // \"input\"" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
            phelp=$(echo "$params_json" | "$YQ" eval ".[$i].help // \"\"" -)
            query_cmd=$(echo "$params_json" | "$YQ" eval ".[$i].query.command // \"\"" -)
            query_url=$(echo "$params_json" | "$YQ" eval ".[$i].query.url // \"\"" -)

            # 变量名
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"

            echo ""
            echo -e "  ${CYAN}$pname${NC} ${YELLOW}($ptype)${NC} → ${GREEN}\${{.$varname}}${NC}"

            # 帮助信息（支持多行）
            if [[ -n "$phelp" && "$phelp" != "null" ]]; then
                echo "$phelp" | while IFS= read -r line; do
                    echo -e "    ${BLUE}$line${NC}"
                done
            fi

            # 默认值
            [[ -n "$pdefault" && "$pdefault" != "null" ]] && echo -e "    Default: ${GREEN}$pdefault${NC}"

            # 静态选项
            if [[ "$ptype" == "select" ]]; then
                poptions=$(echo "$params_json" | "$YQ" eval ".[$i].options | join(\", \")" - 2>/dev/null || true)
                [[ -n "$poptions" && "$poptions" != "null" ]] && echo -e "    Options: $poptions"
            fi

            # 动态查询
            if [[ -n "$query_cmd" && "$query_cmd" != "null" ]]; then
                echo -e "    Source: ${CYAN}command${NC} → $query_cmd"
            elif [[ -n "$query_url" && "$query_url" != "null" ]]; then
                local query_jq
                query_jq=$(echo "$params_json" | "$YQ" eval ".[$i].query.jq // \"\"" -)
                echo -e "    Source: ${CYAN}url${NC} → $query_url"
                [[ -n "$query_jq" && "$query_jq" != "null" ]] && echo -e "    Filter: $query_jq"
            fi
        done
        echo ""

        # 使用示例
        echo -e "${BOLD}Usage:${NC}"
        echo -e "  ./ez run $task"
        local example_vars=""
        for ((i=0; i<count; i++)); do
            local pname pdefault
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"value\"" -)
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"
            example_vars+=" $varname=$pdefault"
        done
        echo -e "  ./ez run $task$example_vars"
    fi
}

# -----------------------------------------------------------------------------
# 交互式参数选择
# -----------------------------------------------------------------------------
select_value() {
    local name="$1" type="$2" options_json="$3" default="$4" help="$5"

    # 所有交互输出到 stderr，只有结果输出到 stdout
    echo -e "${BOLD}$name${NC}" >&2
    [[ -n "$help" && "$help" != "null" ]] && echo -e "  ${CYAN}$help${NC}" >&2

    if [[ "$type" == "select" ]]; then
        local opts=()
        while IFS= read -r opt; do
            [[ -n "$opt" ]] && opts+=("$opt")
        done < <(echo "$options_json" | "$YQ" eval '.[]' - 2>/dev/null)

        if [[ ${#opts[@]} -gt 0 ]]; then
            local i=1
            for opt in "${opts[@]}"; do
                local marker=""
                [[ "$opt" == "$default" ]] && marker=" (default)"
                echo "    $i) $opt$marker" >&2
                ((i++))
            done

            while true; do
                read -rp "  Choice [1-${#opts[@]}]: " choice </dev/tty
                # 回车使用默认值
                if [[ -z "$choice" && -n "$default" ]]; then
                    echo "$default"
                    return
                fi
                if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#opts[@]})); then
                    echo "${opts[$((choice-1))]}"
                    return
                fi
                echo "  无效选择，请重试" >&2
            done
        fi
    fi

    # input 类型或其他
    read -rp "  Value [$default]: " value </dev/tty
    echo "${value:-$default}"
}

# -----------------------------------------------------------------------------
# 命令: run
# -----------------------------------------------------------------------------
cmd_run() {
    local task="${1:-}"
    shift || true
    [[ -z "$task" ]] && die "用法: ez run <task> [options]"

    local taskfile dry_run=false enable_log=false remote_node="" workspace="" no_workspace=false
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 解析选项
    local -a extra_vars=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run) dry_run=true; shift ;;
            --log) enable_log=true; shift ;;
            --node=*) remote_node="${1#--node=}"; shift ;;
            --node) remote_node="$2"; shift 2 ;;
            --workspace=*) workspace="${1#--workspace=}"; shift ;;
            --workspace) workspace="${2:-auto}"; shift 2 ;;
            --no-workspace) no_workspace=true; shift ;;
            *=*) extra_vars+=("$1"); shift ;;
            *) shift ;;
        esac
    done

    # 检查是否需要远程执行
    if [[ -n "$remote_node" ]]; then
        _run_remote_task "$taskfile" "$task" "$remote_node" "$dry_run" "${extra_vars[@]}"
        return $?
    fi

    # Workspace 模式
    if [[ -n "$workspace" ]]; then
        _run_in_workspace "$taskfile" "$task" "$workspace" "$dry_run" "$enable_log" "${extra_vars[@]}"
        return $?
    fi

    # 检查是否是文件夹任务 — 默认在 workspace 中执行
    if is_folder_task "$task"; then
        if [[ "$no_workspace" == "true" ]]; then
            _run_folder_task "$task" "$dry_run" "$enable_log" "${extra_vars[@]}"
        else
            _run_folder_task_in_workspace "$task" "$dry_run" "$enable_log" "${extra_vars[@]}"
        fi
        return $?
    fi

    # 检查是否是组合任务
    if has_ez_compose "$taskfile" "$task"; then
        _run_composed_task "$taskfile" "$task" "$dry_run" "$enable_log" "${extra_vars[@]}"
        return $?
    fi

    # 检查是否是继承任务，获取实际执行的基础任务
    local actual_task="$task"
    local params_json=""
    if has_ez_extends "$taskfile" "$task"; then
        actual_task=$(get_ez_extends "$taskfile" "$task")
        params_json=$(resolve_inherited_params "$taskfile" "$task")
    elif has_ez_params "$taskfile" "$task"; then
        params_json=$(get_ez_params_json "$taskfile" "$task")
    fi

    # 收集 ez-params 参数（交互式）
    if [[ -n "$params_json" && "$params_json" != "[]" && "$params_json" != "null" ]]; then
        echo -e "${BOLD}Configure: ${GREEN}$task${NC}"
        if has_ez_extends "$taskfile" "$task"; then
            echo -e "${DIM}(extends: $actual_task)${NC}"
        fi
        echo ""

        local count
        count=$(echo "$params_json" | "$YQ" eval 'length' -)

        for ((i=0; i<count; i++)); do
            local pname ptype poptions pdefault phelp value
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            ptype=$(echo "$params_json" | "$YQ" eval ".[$i].type // \"input\"" -)
            poptions=$(echo "$params_json" | "$YQ" eval -o=json ".[$i].options // []" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
            phelp=$(echo "$params_json" | "$YQ" eval ".[$i].help // \"\"" -)

            # 检查是否已预设
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"
            local preset=""
            for v in "${extra_vars[@]}"; do
                [[ "$v" == "$varname="* ]] && preset="${v#*=}"
            done

            if [[ -n "$preset" ]]; then
                echo -e "${BOLD}$pname${NC}: $preset (preset)"
                value="$preset"
            else
                # 检查 query.command 动态获取选项
                local query_cmd query_url query_jq
                query_cmd=$(echo "$params_json" | "$YQ" eval ".[$i].query.command // \"\"" -)
                query_url=$(echo "$params_json" | "$YQ" eval ".[$i].query.url // \"\"" -)
                query_jq=$(echo "$params_json" | "$YQ" eval ".[$i].query.jq // \"\"" -)

                if [[ -n "$query_cmd" && "$query_cmd" != "null" && ("$poptions" == "[]" || "$poptions" == "null") ]]; then
                    echo -e "  ${CYAN}(query: $query_cmd)${NC}" >&2
                    local cmd_output
                    if cmd_output=$(eval "$query_cmd" 2>/dev/null); then
                        poptions=$(echo "$cmd_output" | "$YQ" -o=json -I0 'split("\n") | map(select(. != ""))')
                    fi
                elif [[ -n "$query_url" && "$query_url" != "null" && ("$poptions" == "[]" || "$poptions" == "null") ]]; then
                    echo -e "  ${CYAN}(fetch: $query_url)${NC}" >&2
                    local url_output
                    if url_output=$(curl -fsSL "$query_url" 2>/dev/null); then
                        if [[ -n "$query_jq" && "$query_jq" != "null" ]]; then
                            # 使用 jq 表达式提取数据
                            poptions=$(echo "$url_output" | "$YQ" -o=json "$query_jq")
                        else
                            # 假设返回的是每行一个选项
                            poptions=$(echo "$url_output" | "$YQ" -o=json -I0 'split("\n") | map(select(. != ""))')
                        fi
                    fi
                fi

                value=$(select_value "$pname" "$ptype" "$poptions" "$pdefault" "$phelp")
                extra_vars+=("$varname=$value")
            fi
            echo ""
        done
    fi

    # 构建命令 - 使用实际任务
    local -a cmd=("$TASK" "-t" "$taskfile" "$actual_task")
    for v in "${extra_vars[@]}"; do
        cmd+=("$v")
    done

    if $dry_run; then
        echo -e "${BOLD}Dry run:${NC} ${cmd[*]}"
        return 0
    fi

    # pre_run 钩子
    run_hooks "$taskfile" "$task" "pre_run" 0 ""

    echo -e "${BOLD}Running:${NC} ${cmd[*]}"
    echo ""

    # 执行任务并捕获输出和退出码
    local task_output exit_code=0
    if $enable_log; then
        local log_file
        log_file=$(get_task_log_path "$taskfile" "$task" "$(date +%s)")
        write_log_header "$log_file" "$task" "" ""
        echo -e "  ${DIM}Log: $log_file${NC}"
        local start_time=$(date +%s)
        task_output=$("${cmd[@]}" 2>&1) || exit_code=$?
        echo "$task_output"
        echo "$task_output" >> "$log_file"
        local end_time=$(date +%s)
        write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"
    else
        task_output=$("${cmd[@]}" 2>&1) || exit_code=$?
        echo "$task_output"
    fi

    # post_run 或 on_error 钩子
    if [[ $exit_code -eq 0 ]]; then
        run_hooks "$taskfile" "$task" "post_run" "$exit_code" "$task_output"
    else
        run_hooks "$taskfile" "$task" "on_error" "$exit_code" "$task_output"
        return $exit_code
    fi
}

# -----------------------------------------------------------------------------
# 执行文件夹任务 (直接在 tasks/ 目录)
# -----------------------------------------------------------------------------
_run_folder_task() {
    local task="$1" dry_run="$2" enable_log="$3"
    shift 3
    local -a extra_vars=("$@")

    local task_dir="$EZ_TASKS_DIR/$task"
    local ftfile="$task_dir/Taskfile.yml"
    [[ -f "$ftfile" ]] || ftfile="$task_dir/Taskfile.yaml"

    local -a cmd=("$TASK" "-d" "$task_dir" "default")
    for v in "${extra_vars[@]}"; do
        cmd+=("$v")
    done

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Dry run:${NC} ${cmd[*]}"
        return 0
    fi

    echo -e "${BOLD}Running:${NC} ${GREEN}$task${NC} ${MAGENTA}[folder]${NC}"
    echo -e "  ${DIM}Dir: $task_dir${NC}"
    echo ""

    if [[ "$enable_log" == "true" ]]; then
        local log_file
        log_file=$(get_log_path "$task" "$(date +%s)" "$task")
        write_log_header "$log_file" "$task" "" ""
        echo -e "  ${DIM}Log: $log_file${NC}"
        local start_time=$(date +%s)
        local task_output exit_code=0
        task_output=$("${cmd[@]}" 2>&1) || exit_code=$?
        echo "$task_output"
        echo "$task_output" >> "$log_file"
        local end_time=$(date +%s)
        write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"
        return $exit_code
    else
        "${cmd[@]}"
    fi
}

# -----------------------------------------------------------------------------
# 执行文件夹任务 (默认在 .ez/tasks/<name>/workspace/ 中)
# -----------------------------------------------------------------------------
_run_folder_task_in_workspace() {
    local task="$1" dry_run="$2" enable_log="$3"
    shift 3
    local -a extra_vars=("$@")

    local task_dir="$EZ_TASKS_DIR/$task"
    local ftfile="$task_dir/Taskfile.yml"
    [[ -f "$ftfile" ]] || ftfile="$task_dir/Taskfile.yaml"

    # 创建文件夹任务默认 workspace
    local ws_dir
    ws_dir=$(create_workspace "default" "$task")

    # 复制文件夹任务的 Taskfile 到 workspace (非根 Taskfile)
    cp "$ftfile" "$ws_dir/Taskfile.yml"

    echo -e "${BOLD}Task:${NC} ${GREEN}$task${NC} ${MAGENTA}[folder]${NC}"
    echo -e "  ${DIM}Workspace: $ws_dir${NC}"
    echo ""

    local -a cmd=("$TASK" "-d" "$ws_dir" "default")
    for v in "${extra_vars[@]}"; do
        cmd+=("$v")
    done

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Dry run:${NC} ${cmd[*]}"
        return 0
    fi

    if [[ "$enable_log" == "true" ]]; then
        local log_file
        log_file=$(get_log_path "$task" "$(date +%s)" "$task")
        write_log_header "$log_file" "$task" "" "workspace"
        echo -e "  ${DIM}Log: $log_file${NC}"
        local start_time=$(date +%s)
        local exit_code=0
        "${cmd[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
        local end_time=$(date +%s)
        write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"
        return $exit_code
    else
        "${cmd[@]}"
    fi
}

# -----------------------------------------------------------------------------
# Workspace 隔离执行
# -----------------------------------------------------------------------------
_run_in_workspace() {
    local taskfile="$1" task="$2" ws_name="$3" dry_run="$4" enable_log="$5"
    shift 5
    local -a extra_vars=("$@")

    # 创建工作区
    local ws_dir
    ws_dir=$(create_workspace "$ws_name")
    ws_name=$(basename "$ws_dir")

    echo -e "${BOLD}Workspace:${NC} ${MAGENTA}$ws_name${NC}"
    echo -e "  Dir: $ws_dir"
    echo -e "  Src: $ws_dir/src → $EZ_ROOT"
    echo ""

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Dry run:${NC} $TASK -d $ws_dir $task ${extra_vars[*]}"
        return 0
    fi

    echo -e "${BOLD}Running:${NC} ${GREEN}$task${NC} in workspace"
    echo ""

    local -a cmd=("$TASK" "-d" "$ws_dir" "$task")
    for v in "${extra_vars[@]}"; do
        cmd+=("$v")
    done

    if [[ "$enable_log" == "true" ]]; then
        init_log_dir
        local log_file
        log_file=$(get_log_path "$task" "$(date +%s)")
        write_log_header "$log_file" "$task" "" "workspace=$ws_name"
        echo -e "  ${DIM}Log: $log_file${NC}"
        local start_time=$(date +%s)
        local exit_code=0
        "${cmd[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
        local end_time=$(date +%s)
        write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"
        return $exit_code
    else
        "${cmd[@]}"
    fi
}

# -----------------------------------------------------------------------------
# 执行组合任务
# -----------------------------------------------------------------------------
_run_composed_task() {
    local taskfile="$1" task="$2" dry_run="$3" enable_log="$4"
    shift 4
    local -a extra_vars=("$@")

    local compose_json
    compose_json=$(get_ez_compose_json "$taskfile" "$task")
    local compose_count
    compose_count=$(echo "$compose_json" | "$YQ" eval 'length' -)

    # 获取组合任务的全局默认值
    local task_defaults
    task_defaults=$(get_ez_defaults_json "$taskfile" "$task")

    echo -e "${BOLD}========================================${NC}"
    echo -e "${BOLD}Composed Task: ${GREEN}$task${NC} ($compose_count tasks)"
    echo -e "${BOLD}========================================${NC}"
    echo ""

    local overall_exit=0
    for ((i=0; i<compose_count; i++)); do
        local ctask cdefaults step_num=$((i+1))
        ctask=$(echo "$compose_json" | "$YQ" eval ".[$i].task" -)
        cdefaults=$(echo "$compose_json" | "$YQ" eval -o=json ".[$i].defaults // {}" -)

        echo -e "${BOLD}[$step_num/$compose_count] $ctask${NC}"

        # 构建变量列表: 全局默认 < 步骤默认 < 用户预设
        local -a task_vars=()

        # 1. 全局默认值
        if [[ "$task_defaults" != "{}" && "$task_defaults" != "null" ]]; then
            while IFS= read -r key; do
                [[ -z "$key" ]] && continue
                local val
                val=$(echo "$task_defaults" | "$YQ" eval ".$key" -)
                task_vars+=("$key=$val")
            done < <(echo "$task_defaults" | "$YQ" eval 'keys | .[]' -)
        fi

        # 2. 步骤默认值 (覆盖全局)
        if [[ "$cdefaults" != "{}" && "$cdefaults" != "null" ]]; then
            while IFS= read -r key; do
                [[ -z "$key" ]] && continue
                local val
                val=$(echo "$cdefaults" | "$YQ" eval ".$key" -)
                # 删除已存在的同名变量
                local -a new_vars=()
                for v in "${task_vars[@]}"; do
                    [[ "$v" != "$key="* ]] && new_vars+=("$v")
                done
                task_vars=("${new_vars[@]}" "$key=$val")
            done < <(echo "$cdefaults" | "$YQ" eval 'keys | .[]' -)
        fi

        # 3. 用户预设 (最高优先级)
        for v in "${extra_vars[@]}"; do
            local vkey="${v%%=*}"
            local -a new_vars=()
            for tv in "${task_vars[@]}"; do
                [[ "$tv" != "$vkey="* ]] && new_vars+=("$tv")
            done
            task_vars=("${new_vars[@]}" "$v")
        done

        local -a cmd=("$TASK" "-t" "$taskfile" "$ctask")
        for v in "${task_vars[@]}"; do
            cmd+=("$v")
        done

        if [[ "$dry_run" == "true" ]]; then
            echo "  [dry-run] ${cmd[*]}"
        elif [[ "$enable_log" == "true" ]]; then
            local log_file
            log_file=$(get_task_log_path "$taskfile" "$ctask" "$(date +%s)")
            write_log_header "$log_file" "$ctask" "" "compose:$task"
            echo -e "  ${DIM}Log: $log_file${NC}"
            local start_time=$(date +%s)
            local task_output exit_code=0
            task_output=$("${cmd[@]}" 2>&1) || exit_code=$?
            echo "$task_output"
            echo "$task_output" >> "$log_file"
            local end_time=$(date +%s)
            write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"
            [[ $exit_code -ne 0 ]] && overall_exit=$exit_code && break
        else
            "${cmd[@]}" || { overall_exit=$?; break; }
        fi
        echo ""
    done

    echo -e "${BOLD}========================================${NC}"
    if [[ $overall_exit -eq 0 ]]; then
        echo -e "${GREEN}✓ Composed task completed: $task${NC}"
    else
        echo -e "${RED}✗ Composed task failed: $task (exit: $overall_exit)${NC}"
    fi
    echo -e "${BOLD}========================================${NC}"

    return $overall_exit
}

# -----------------------------------------------------------------------------
# 远程任务执行
# -----------------------------------------------------------------------------
_run_remote_task() {
    local taskfile="$1" task="$2" node="$3" dry_run="$4"
    shift 4
    local -a extra_vars=("$@")

    # 检查是否有服务器配置
    local server_url="${EZ_SERVER_URL:-}"
    if [[ -z "$server_url" ]]; then
        # 尝试从配置文件读取
        if [[ -f "$EZ_ROOT/.ez-config.yml" ]]; then
            server_url=$("$YQ" eval '.server.url // ""' "$EZ_ROOT/.ez-config.yml" 2>/dev/null)
        fi
    fi

    if [[ -z "$server_url" ]]; then
        die "远程执行需要配置服务器地址。设置 EZ_SERVER_URL 或在 .ez-config.yml 中配置 server.url"
    fi

    echo -e "${BOLD}Remote Execution${NC}"
    echo -e "  Task:   ${GREEN}$task${NC}"
    echo -e "  Node:   ${CYAN}$node${NC}"
    echo -e "  Server: ${DIM}$server_url${NC}"
    echo ""

    # 构建变量 JSON
    local vars_json="{"
    local first=true
    for v in "${extra_vars[@]}"; do
        local key="${v%%=*}"
        local val="${v#*=}"
        if ! $first; then vars_json+=","; fi
        vars_json+="\"$key\":\"$val\""
        first=false
    done
    vars_json+="}"

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Dry run:${NC}"
        echo "  POST $server_url/api/v1/tasks/run"
        echo "  Body: {\"task\":\"$task\",\"node\":\"$node\",\"vars\":$vars_json}"
        return 0
    fi

    # 检查 curl 是否可用
    if ! command -v curl &>/dev/null; then
        die "curl 未安装，无法执行远程任务"
    fi

    # 发送任务到服务器
    local response
    response=$(curl -sf -X POST "$server_url/api/v1/tasks/run" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${EZ_SERVER_TOKEN:-}" \
        -d "{\"task\":\"$task\",\"node\":\"$node\",\"vars\":$vars_json}" 2>&1) || {
        die "远程任务提交失败: $response"
    }

    local job_id
    job_id=$(echo "$response" | "$YQ" eval '.job_id // ""' -)
    if [[ -z "$job_id" || "$job_id" == "null" ]]; then
        die "无法获取任务 ID: $response"
    fi

    echo -e "  Job ID: ${YELLOW}$job_id${NC}"
    echo ""
    echo -e "${BOLD}Streaming logs...${NC}"
    echo ""

    # 流式获取日志 (SSE)
    curl -sf "$server_url/api/v1/jobs/$job_id/logs" \
        -H "Authorization: Bearer ${EZ_SERVER_TOKEN:-}" \
        --no-buffer 2>/dev/null || true

    # 获取最终状态
    local status exit_code
    status=$(curl -sf "$server_url/api/v1/jobs/$job_id" \
        -H "Authorization: Bearer ${EZ_SERVER_TOKEN:-}" 2>/dev/null)
    exit_code=$(echo "$status" | "$YQ" eval '.exit_code // 1' -)

    echo ""
    if [[ "$exit_code" -eq 0 ]]; then
        echo -e "${GREEN}✓ Remote task completed${NC}"
    else
        echo -e "${RED}✗ Remote task failed (exit: $exit_code)${NC}"
    fi

    return "$exit_code"
}

# -----------------------------------------------------------------------------
# Plan 计划相关函数
# -----------------------------------------------------------------------------
PLAN_FILE=".ez-plan.yml"

find_planfile() {
    [[ -f "$PLAN_FILE" ]] && echo "$PLAN_FILE" && return 0
    [[ -f ".ez-plan.yaml" ]] && echo ".ez-plan.yaml" && return 0
    return 1
}

# plan list - 列出所有计划（合并 plans/ 目录 + 旧格式）
cmd_plan_list() {
    echo -e "${BOLD}Plans:${NC}"
    echo ""

    local found=false

    # 1. plans/ 目录中的新格式 Plan
    if [[ -d "$EZ_PLANS_DIR" ]]; then
        for f in "$EZ_PLANS_DIR"/*.yml "$EZ_PLANS_DIR"/*.yaml; do
            [[ ! -f "$f" ]] && continue
            found=true
            local name desc step_count
            name=$(basename "$f" | sed 's/\.\(yml\|yaml\)$//')
            desc=$("$YQ" eval '.desc // ""' "$f")
            step_count=$("$YQ" eval '.steps // [] | length' "$f")
            printf "  ${GREEN}%-20s${NC} %s ${CYAN}[%s steps]${NC} ${MAGENTA}[v1.2]${NC}\n" "$name" "$desc" "$step_count"
        done
    fi

    # 2. 旧格式 .ez-plan.yml
    local planfile
    if planfile=$(find_planfile); then
        local plans
        plans=$("$YQ" eval '.plans | keys | .[]' "$planfile" 2>/dev/null)
        while IFS= read -r name; do
            [[ -z "$name" ]] && continue
            found=true
            local desc step_count
            desc=$("$YQ" eval ".plans.\"$name\".desc // \"\"" "$planfile")
            step_count=$("$YQ" eval ".plans.\"$name\".steps | length" "$planfile")
            printf "  ${GREEN}%-20s${NC} %s ${CYAN}[%s steps]${NC}\n" "$name" "$desc" "$step_count"
        done <<< "$plans"
    fi

    if ! $found; then
        echo "  (无计划)"
        echo ""
        echo "  创建: ez plan new <name> --desc \"描述\""
    fi
}

# plan show - 显示计划详情
cmd_plan_show() {
    local plan="${1:-}"
    [[ -z "$plan" ]] && die "用法: ez plan show <plan>"

    # 尝试新格式
    local plan_file
    if plan_file=$(find_plan_file "$plan"); then
        _show_new_plan "$plan_file" "$plan"
        return
    fi

    # 回退旧格式
    local planfile
    planfile=$(find_planfile) || die "计划未找到: $plan"

    local exists
    exists=$("$YQ" eval ".plans.\"$plan\" // \"\"" "$planfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "计划未找到: $plan"

    echo -e "${BOLD}Plan: ${GREEN}$plan${NC}"
    echo ""

    local desc
    desc=$("$YQ" eval ".plans.\"$plan\".desc // \"\"" "$planfile")
    [[ -n "$desc" ]] && echo -e "${BOLD}Description:${NC} $desc" && echo ""

    echo -e "${BOLD}Steps:${NC}"
    local steps_json
    steps_json=$("$YQ" eval -o=json ".plans.\"$plan\".steps // []" "$planfile")
    local step_count
    step_count=$(echo "$steps_json" | "$YQ" eval 'length' -)

    for ((i=0; i<step_count; i++)); do
        local sname stask scheckpoint smatrix
        sname=$(echo "$steps_json" | "$YQ" eval ".[$i].name // \"step-$i\"" -)
        stask=$(echo "$steps_json" | "$YQ" eval ".[$i].task // \"\"" -)
        scheckpoint=$(echo "$steps_json" | "$YQ" eval ".[$i].checkpoint // false" -)
        smatrix=$(echo "$steps_json" | "$YQ" eval ".[$i].matrix // \"\"" -)

        local step_num=$((i+1))
        if [[ "$scheckpoint" == "true" ]]; then
            local prompt
            prompt=$(echo "$steps_json" | "$YQ" eval ".[$i].prompt // \"Continue?\"" -)
            echo -e "  ${YELLOW}$step_num. ⏸ $sname${NC} (checkpoint)"
            echo -e "     ${CYAN}$prompt${NC}"
        elif [[ -n "$smatrix" && "$smatrix" != "null" ]]; then
            echo -e "  ${CYAN}$step_num. $sname${NC} → task:$stask [matrix]"
        else
            echo -e "  ${CYAN}$step_num. $sname${NC} → task:$stask"
        fi
    done
}

# 显示新格式 Plan 详情
_show_new_plan() {
    local plan_file="$1" plan="$2"

    local plan_name plan_desc
    plan_name=$("$YQ" eval '.name // ""' "$plan_file")
    plan_desc=$("$YQ" eval '.desc // ""' "$plan_file")

    echo -e "${BOLD}Plan: ${GREEN}$plan${NC} ${MAGENTA}[v1.2]${NC}"
    echo -e "  File: $plan_file"
    echo ""

    [[ -n "$plan_desc" ]] && echo -e "${BOLD}Description:${NC} $plan_desc" && echo ""

    local steps_json
    steps_json=$("$YQ" eval -o=json '.steps // []' "$plan_file")
    local step_count
    step_count=$(echo "$steps_json" | "$YQ" eval 'length' -)

    echo -e "${BOLD}Steps:${NC} ($step_count)"
    for ((i=0; i<step_count; i++)); do
        local sname stask sneeds sartifacts sinputs sshuffle
        sname=$(echo "$steps_json" | "$YQ" eval ".[$i].name // \"step-$i\"" -)
        stask=$(echo "$steps_json" | "$YQ" eval ".[$i].task // \"\"" -)
        sneeds=$(echo "$steps_json" | "$YQ" eval ".[$i].needs // [] | join(\", \")" -)
        sartifacts=$(echo "$steps_json" | "$YQ" eval ".[$i].artifacts // [] | .[].name" - 2>/dev/null)
        sinputs=$(echo "$steps_json" | "$YQ" eval ".[$i].inputs // [] | length" -)
        sshuffle=$(echo "$steps_json" | "$YQ" eval ".[$i].shuffle // false" -)

        local step_num=$((i+1))
        local flags=""
        [[ -n "$sneeds" ]] && flags+=" needs:[$sneeds]"
        [[ -n "$sartifacts" ]] && flags+=" artifacts"
        [[ "$sinputs" -gt 0 ]] 2>/dev/null && flags+=" inputs:$sinputs"
        [[ "$sshuffle" == "true" ]] && flags+=" shuffle"

        echo -e "  ${CYAN}$step_num. $sname${NC} → task:$stask${DIM}$flags${NC}"
    done

    # 显示 matrix 如果有
    local matrix
    matrix=$("$YQ" eval '.matrix // ""' "$plan_file" 2>/dev/null)
    if [[ -n "$matrix" && "$matrix" != "null" && "$matrix" != "" ]]; then
        echo ""
        echo -e "${BOLD}Matrix:${NC}"
        "$YQ" eval '.matrix' "$plan_file" 2>/dev/null | while IFS= read -r line; do
            echo "  $line"
        done
    fi

    # 显示编译状态
    local build_file="$EZ_BUILD_DIR/$plan/Taskfile.yml"
    if [[ -f "$build_file" ]]; then
        echo ""
        echo -e "${BOLD}Build:${NC} ${GREEN}compiled${NC} ($build_file)"
    fi
}

# plan new - 创建新的 Plan 文件
cmd_plan_new() {
    local name="" desc=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --desc|--description) desc="$2"; shift 2 ;;
            --desc=*) desc="${1#--desc=}"; shift ;;
            *) [[ -z "$name" ]] && name="$1" || shift; shift ;;
        esac
    done

    [[ -z "$name" ]] && die "用法: ez plan new <name> [--desc \"描述\"]"

    mkdir -p "$EZ_PLANS_DIR"

    local plan_file="$EZ_PLANS_DIR/$name.yml"
    if [[ -f "$plan_file" ]]; then
        die "Plan 已存在: $plan_file"
    fi

    cat > "$plan_file" << EOF
name: $name
desc: "$desc"
steps: []
EOF

    echo -e "${GREEN}✓ Plan created: $plan_file${NC}"
    echo "  添加步骤: ez plan add $name <task>"
}

# plan add - 向 Plan 添加步骤
cmd_plan_add() {
    local plan_name="${1:-}"
    local task_name="${2:-}"
    shift 2 2>/dev/null || true

    [[ -z "$plan_name" || -z "$task_name" ]] && die "用法: ez plan add <plan> <task> [--name <step-name>] [--needs <step1,step2>]"

    local plan_file
    plan_file=$(find_plan_file "$plan_name") || die "Plan 未找到: $plan_name\n  创建: ez plan new $plan_name"

    local step_name="$task_name" needs=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name) step_name="$2"; shift 2 ;;
            --name=*) step_name="${1#--name=}"; shift ;;
            --needs) needs="$2"; shift 2 ;;
            --needs=*) needs="${1#--needs=}"; shift ;;
            *) shift ;;
        esac
    done

    # 构建新的 step YAML
    local new_step
    if [[ -n "$needs" ]]; then
        # 将逗号分隔转为 YAML 数组
        local needs_yaml="["
        IFS=',' read -ra needs_arr <<< "$needs"
        for ((i=0; i<${#needs_arr[@]}; i++)); do
            [[ $i -gt 0 ]] && needs_yaml+=", "
            needs_yaml+="\"${needs_arr[$i]}\""
        done
        needs_yaml+="]"
        new_step="{\"name\": \"$step_name\", \"task\": \"$task_name\", \"needs\": $needs_yaml}"
    else
        new_step="{\"name\": \"$step_name\", \"task\": \"$task_name\"}"
    fi

    # 追加步骤
    "$YQ" eval -i ".steps += [$new_step]" "$plan_file"

    local step_count
    step_count=$("$YQ" eval '.steps | length' "$plan_file")

    echo -e "${GREEN}✓ Step added: $step_name → task:$task_name${NC}"
    [[ -n "$needs" ]] && echo -e "  needs: $needs"
    echo -e "  Plan $plan_name now has $step_count step(s)"
}

# plan build - 编译 Plan 为可执行 Taskfile
cmd_plan_build() {
    local plan_name="${1:-}"
    [[ -z "$plan_name" ]] && die "用法: ez plan build <plan>"

    local plan_file
    plan_file=$(find_plan_file "$plan_name") || die "Plan 未找到: $plan_name"

    echo -e "${BOLD}Building plan: $plan_name${NC}"
    echo "  Source: $plan_file"

    local output_dir
    output_dir=$(get_plan_build_dir "$plan_name")
    local output_file
    output_file=$(compile_plan "$plan_file" "$output_dir") || die "编译失败"

    echo -e "  Output: ${GREEN}$output_file${NC}"
    echo ""
    echo -e "${GREEN}✓ Plan compiled successfully${NC}"
    echo "  审查: cat $output_file"
    echo "  执行: ez plan run $plan_name"
}

# plan check - 验证 Plan 依赖完备性
cmd_plan_check() {
    local plan_name="${1:-}"
    [[ -z "$plan_name" ]] && die "用法: ez plan check <plan>"

    local plan_file
    plan_file=$(find_plan_file "$plan_name") || die "Plan 未找到: $plan_name"

    echo -e "${BOLD}Validating plan: $plan_name${NC}"
    echo ""

    local result
    result=$(validate_plan "$plan_file")
    local exit_code=$?

    echo "$result"
    echo ""

    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}✓ Plan validation passed${NC}"
    else
        echo -e "${RED}✗ Plan validation failed ($exit_code error(s))${NC}"
        return 1
    fi
}

# plan run - 编译 + 验证 + 执行 (v1.2 新格式)
# 保持旧格式兼容
cmd_plan_run() {
    local plan="${1:-}"
    shift || true
    [[ -z "$plan" ]] && die "用法: ez plan run <plan> [--dry-run] [--resume] [--log]"

    local dry_run=false resume=false enable_log=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run) dry_run=true; shift ;;
            --resume) resume=true; shift ;;
            --log) enable_log=true; shift ;;
            *) shift ;;
        esac
    done

    # 尝试新格式 (plans/ 目录)
    local plan_file
    if plan_file=$(find_plan_file "$plan"); then
        _run_new_plan "$plan_file" "$plan" "$dry_run" "$enable_log"
        return $?
    fi

    # 回退旧格式
    local planfile
    planfile=$(find_planfile) || die "计划未找到: $plan"

    local exists
    exists=$("$YQ" eval ".plans.\"$plan\" // \"\"" "$planfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "计划未找到: $plan"

    _run_old_plan "$planfile" "$plan" "$dry_run" "$resume" "$enable_log"
}

# 执行新格式 Plan (编译 → 验证 → 执行)
_run_new_plan() {
    local plan_file="$1" plan_name="$2" dry_run="$3" enable_log="$4"

    local output_dir
    output_dir=$(get_plan_build_dir "$plan_name")

    # Step 1: 编译
    echo -e "${BOLD}[1/3] Compiling plan...${NC}"
    local output_taskfile
    output_taskfile=$(compile_plan "$plan_file" "$output_dir") || die "编译失败"
    echo -e "  ${GREEN}✓${NC} $output_taskfile"

    # Step 2: 验证
    echo -e "${BOLD}[2/3] Validating plan...${NC}"
    if validate_plan "$plan_file" >/dev/null 2>&1; then
        echo -e "  ${GREEN}✓${NC} Validation passed"
    else
        echo -e "  ${YELLOW}⚠${NC} Validation warnings (continuing)"
    fi

    # Step 3: 执行
    echo -e "${BOLD}[3/3] Executing plan...${NC}"
    echo ""

    export EZ_RUN_ID="$(date +%Y%m%d-%H%M%S)-$$"

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Dry run:${NC} $TASK -d $output_dir default"
        echo ""
        echo -e "${DIM}Generated Taskfile:${NC}"
        cat "$output_taskfile"
        return 0
    fi

    if [[ "$enable_log" == "true" ]]; then
        init_log_dir
        local log_file
        log_file=$(get_log_path "$plan_name" "$(date +%s)")
        write_log_header "$log_file" "plan:$plan_name" "" ""
        echo -e "  ${DIM}Log: $log_file${NC}"

        local start_time=$(date +%s)
        local exit_code=0
        "$TASK" -d "$output_dir" default 2>&1 | tee -a "$log_file" || exit_code=$?
        local end_time=$(date +%s)
        write_log_footer "$log_file" "$exit_code" "$((end_time - start_time))"

        echo ""
        if [[ $exit_code -eq 0 ]]; then
            echo -e "${GREEN}✓ Plan completed: $plan_name${NC}"
        else
            echo -e "${RED}✗ Plan failed: $plan_name (exit $exit_code)${NC}"
        fi
        return $exit_code
    else
        "$TASK" -d "$output_dir" default
    fi
}

# 执行旧格式 Plan (直接执行)
_run_old_plan() {
    local planfile="$1" plan="$2" dry_run="$3" resume="$4" enable_log="$5"

    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 状态文件
    local state_dir="$EZ_STATE_DIR"
    local state_file="$state_dir/$plan.state"
    mkdir -p "$state_dir"

    local start_step=0
    if [[ "$resume" == "true" ]] && [[ -f "$state_file" ]]; then
        start_step=$(cat "$state_file")
        echo -e "${YELLOW}⏩ 从步骤 $((start_step+1)) 恢复${NC}"
    fi

    # 设置日志上下文
    export EZ_CURRENT_PLAN="$plan"
    export EZ_RUN_ID="$(date +%Y%m%d-%H%M%S)-$$"

    echo -e "${BOLD}========================================${NC}"
    echo -e "${BOLD}Plan: ${GREEN}$plan${NC}"
    if [[ "$enable_log" == "true" ]]; then
        echo -e "${BOLD}Run ID: ${CYAN}$EZ_RUN_ID${NC}"
    fi
    echo -e "${BOLD}========================================${NC}"
    echo ""

    local steps_json
    steps_json=$("$YQ" eval -o=json ".plans.\"$plan\".steps // []" "$planfile")
    local step_count
    step_count=$(echo "$steps_json" | "$YQ" eval 'length' -)

    for ((i=start_step; i<step_count; i++)); do
        local sname stask scheckpoint smatrix svars sprompt swhen
        sname=$(echo "$steps_json" | "$YQ" eval ".[$i].name // \"step-$i\"" -)
        stask=$(echo "$steps_json" | "$YQ" eval ".[$i].task // \"\"" -)
        scheckpoint=$(echo "$steps_json" | "$YQ" eval ".[$i].checkpoint // false" -)
        smatrix=$(echo "$steps_json" | "$YQ" eval -o=json ".[$i].matrix // null" -)
        svars=$(echo "$steps_json" | "$YQ" eval -o=json ".[$i].vars // {}" -)
        swhen=$(echo "$steps_json" | "$YQ" eval ".[$i].when // \"\"" -)

        local step_num=$((i+1))

        # when 条件检查
        if [[ -n "$swhen" && "$swhen" != "null" ]]; then
            local env_var
            env_var=$(echo "$swhen" | sed -n 's/.*env\.\([A-Za-z_][A-Za-z0-9_]*\).*/\1/p')
            if [[ -n "$env_var" ]]; then
                local env_val="${!env_var:-}"
                if [[ -z "$env_val" || "$env_val" == "false" || "$env_val" == "0" ]]; then
                    echo -e "${DIM}[$step_num/$step_count] $sname (skipped: $env_var not set)${NC}"
                    echo ""
                    continue
                fi
            fi
        fi

        echo -e "${BOLD}[$step_num/$step_count] $sname${NC}"

        # 保存状态
        if [[ "$dry_run" != "true" ]]; then
            echo "$i" > "$state_file"
        fi

        # 检查点
        if [[ "$scheckpoint" == "true" ]]; then
            sprompt=$(echo "$steps_json" | "$YQ" eval ".[$i].prompt // \"Continue?\"" -)
            echo -e "${YELLOW}⏸ Checkpoint: $sprompt${NC}"
            if [[ "$dry_run" != "true" ]]; then
                read -rp "  Press Enter to continue, or Ctrl+C to abort..." </dev/tty
            fi
            echo ""
            continue
        fi

        # 设置步骤上下文
        export EZ_CURRENT_STEP="$sname"

        # 矩阵执行
        if [[ "$smatrix" != "null" ]]; then
            _run_matrix_step "$taskfile" "$stask" "$smatrix" "$svars" "$dry_run" "$enable_log"
            echo ""
            continue
        fi

        # 普通任务
        local -a task_vars=()
        if [[ "$svars" != "{}" && "$svars" != "null" ]]; then
            while IFS= read -r key; do
                [[ -z "$key" ]] && continue
                local val
                val=$(echo "$svars" | "$YQ" eval ".$key" -)
                task_vars+=("$key=$val")
            done < <(echo "$svars" | "$YQ" eval 'keys | .[]' -)
        fi

        if [[ "$dry_run" == "true" ]]; then
            echo "  [dry-run] $TASK -t $taskfile $stask ${task_vars[*]}"
        elif [[ "$enable_log" == "true" ]]; then
            run_task_with_log "$taskfile" "$stask" "${task_vars[@]}"
        else
            "$TASK" -t "$taskfile" "$stask" "${task_vars[@]}"
        fi
        echo ""
    done

    # 完成后删除状态文件
    rm -f "$state_file"

    echo -e "${BOLD}========================================${NC}"
    echo -e "${GREEN}✓ Plan completed: $plan${NC}"
    if [[ "$enable_log" == "true" ]]; then
        echo -e "${CYAN}Logs: $EZ_LOG_DIR/${NC}"
    fi
    echo -e "${BOLD}========================================${NC}"
}

# 矩阵步骤执行 (支持多维)
_run_matrix_step() {
    local taskfile="$1" stask="$2" smatrix="$3" svars="$4" dry_run="$5" enable_log="${6:-false}"

    local matrix_keys
    matrix_keys=$(echo "$smatrix" | "$YQ" eval 'keys | .[]' -)
    local key_array=()
    while IFS= read -r k; do
        [[ -n "$k" ]] && key_array+=("$k")
    done <<< "$matrix_keys"

    if [[ ${#key_array[@]} -eq 1 ]]; then
        local key="${key_array[0]}"
        local values
        values=$(echo "$smatrix" | "$YQ" eval ".$key[]" -)
        while IFS= read -r val; do
            [[ -z "$val" ]] && continue
            _run_matrix_task "$taskfile" "$stask" "$svars" "$key" "$val" "" "" "$dry_run" "$enable_log"
        done <<< "$values"
    elif [[ ${#key_array[@]} -ge 2 ]]; then
        local key1="${key_array[0]}" key2="${key_array[1]}"
        local values1 values2
        values1=$(echo "$smatrix" | "$YQ" eval ".$key1[]" -)
        values2=$(echo "$smatrix" | "$YQ" eval ".$key2[]" -)
        while IFS= read -r v1; do
            [[ -z "$v1" ]] && continue
            while IFS= read -r v2; do
                [[ -z "$v2" ]] && continue
                _run_matrix_task "$taskfile" "$stask" "$svars" "$key1" "$v1" "$key2" "$v2" "$dry_run" "$enable_log"
            done <<< "$values2"
        done <<< "$values1"
    fi
}

# 执行单个矩阵任务
_run_matrix_task() {
    local taskfile="$1" stask="$2" svars="$3"
    local key1="$4" val1="$5" key2="$6" val2="$7" dry_run="$8" enable_log="${9:-false}"

    local -a task_vars=()
    local label="$key1=$val1"
    [[ -n "$key2" ]] && label="$key1=$val1, $key2=$val2"

    if [[ "$svars" != "{}" && "$svars" != "null" ]]; then
        while IFS= read -r vkey; do
            [[ -z "$vkey" ]] && continue
            local vval
            vval=$(echo "$svars" | "$YQ" eval ".$vkey" -)
            vval="${vval//\{\{.${key1}\}\}/$val1}"
            [[ -n "$key2" ]] && vval="${vval//\{\{.${key2}\}\}/$val2}"
            task_vars+=("$vkey=$vval")
        done < <(echo "$svars" | "$YQ" eval 'keys | .[]' -)
    fi

    echo -e "  ${CYAN}→ $stask ($label)${NC}"
    if [[ "$dry_run" == "true" ]]; then
        echo "    [dry-run] $TASK -t $taskfile $stask ${task_vars[*]}"
    elif [[ "$enable_log" == "true" ]]; then
        run_task_with_log "$taskfile" "$stask" "${task_vars[@]}"
    else
        "$TASK" -t "$taskfile" "$stask" "${task_vars[@]}"
    fi
}

# plan 命令路由 (v1.2: 支持 new/add/build/check + implicit run)
cmd_plan() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)    cmd_plan_list "$@" ;;
        show)       cmd_plan_show "$@" ;;
        run)        cmd_plan_run "$@" ;;
        new|create) cmd_plan_new "$@" ;;
        add)        cmd_plan_add "$@" ;;
        build)      cmd_plan_build "$@" ;;
        check)      cmd_plan_check "$@" ;;
        *)
            # 尝试作为 plan 名直接执行 (implicit run)
            if find_plan_file "$subcmd" >/dev/null 2>&1; then
                cmd_plan_run "$subcmd" "$@"
            else
                # 检查旧格式
                local planfile
                if planfile=$(find_planfile); then
                    local exists
                    exists=$("$YQ" eval ".plans.\"$subcmd\" // \"\"" "$planfile")
                    if [[ -n "$exists" && "$exists" != "null" ]]; then
                        cmd_plan_run "$subcmd" "$@"
                        return
                    fi
                fi
                die "未知 plan 子命令或计划: $subcmd\n  提示: ez plan list 查看所有计划"
            fi
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Template 模板命令
# -----------------------------------------------------------------------------

# 查找模板目录
find_template_dir() {
    local dirs=("$EZ_ROOT/templates" "$HOME/.ez/templates")
    for d in "${dirs[@]}"; do
        [[ -d "$d" ]] && echo "$d" && return 0
    done
    return 1
}

# template list - 列出可用模板
cmd_template_list() {
    local tpl_dir
    tpl_dir=$(find_template_dir) || die "未找到模板目录"

    echo -e "${BOLD}Templates in ${tpl_dir}:${NC}"
    echo ""

    for f in "$tpl_dir"/*.yml; do
        [[ ! -f "$f" ]] && continue
        local name desc
        name=$("$YQ" eval '.name // ""' "$f")
        desc=$("$YQ" eval '.desc // ""' "$f")
        printf "  ${GREEN}%-20s${NC} %s\n" "$name" "$desc"
    done
}

# template show - 显示模板详情
cmd_template_show() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez template show <name>"

    local tpl_dir tpl_file
    tpl_dir=$(find_template_dir) || die "未找到模板目录"
    tpl_file="$tpl_dir/$name.yml"
    [[ ! -f "$tpl_file" ]] && die "模板未找到: $name"

    local desc version
    desc=$("$YQ" eval '.desc // ""' "$tpl_file")
    version=$("$YQ" eval '.version // ""' "$tpl_file")

    echo -e "${BOLD}Template: ${GREEN}$name${NC}"
    echo -e "${BOLD}Version:${NC} $version"
    echo ""
    echo -e "${BOLD}Description:${NC} $desc"
    echo ""
    echo -e "${BOLD}Parameters:${NC}"

    local params_json
    params_json=$("$YQ" eval -o=json '.params // []' "$tpl_file")
    local param_count
    param_count=$(echo "$params_json" | "$YQ" eval 'length' -)

    for ((i=0; i<param_count; i++)); do
        local pname pdesc pdefault
        pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
        pdesc=$(echo "$params_json" | "$YQ" eval ".[$i].desc // \"\"" -)
        pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
        echo -e "  ${CYAN}$pname${NC}"
        echo "    $pdesc"
        echo -e "    Default: ${GREEN}$pdefault${NC}"
    done

    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  ez template use $name --name=myproject"
}

# template use - 使用模板生成任务
cmd_template_use() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez template use <name> [--param=value ...]"
    shift || true

    local tpl_dir tpl_file is_ytt=false
    tpl_dir=$(find_template_dir) || die "未找到模板目录"

    # 检查是否为 ytt 模板
    if [[ -f "$tpl_dir/$name.ytt.yml" ]]; then
        tpl_file="$tpl_dir/$name.ytt.yml"
        is_ytt=true
    elif [[ -f "$tpl_dir/$name.yml" ]]; then
        tpl_file="$tpl_dir/$name.yml"
    else
        die "模板未找到: $name"
    fi

    # ytt 模板处理
    if $is_ytt; then
        if [[ ! -x "$YTT" ]]; then
            die "ytt 未安装，请运行: ./dep/install-deps.sh"
        fi

        # 构建 ytt 参数
        local -a ytt_args=("-f" "$tpl_file")
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --*=*)
                    local key="${1%%=*}"
                    key="${key#--}"
                    local val="${1#*=}"
                    ytt_args+=("--data-value" "$key=$val")
                    shift
                    ;;
                *)
                    shift
                    ;;
            esac
        done

        echo -e "${BOLD}Generated tasks (ytt):${NC}"
        echo ""
        "$YTT" "${ytt_args[@]}"
        echo ""
        echo -e "${YELLOW}提示: 将上述内容添加到 Taskfile.yml${NC}"
        return
    fi

    # 普通模板处理
    declare -A tpl_params
    local params_json
    params_json=$("$YQ" eval -o=json '.params // []' "$tpl_file")
    local param_count
    param_count=$(echo "$params_json" | "$YQ" eval 'length' -)

    # 加载默认值
    for ((i=0; i<param_count; i++)); do
        local pname pdefault
        pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
        pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
        tpl_params["$pname"]="$pdefault"
    done

    # 覆盖命令行参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*=*)
                local key="${1%%=*}"
                key="${key#--}"
                local val="${1#*=}"
                tpl_params["$key"]="$val"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # 读取模板内容
    local template
    template=$("$YQ" eval '.template' "$tpl_file")

    # 替换模板变量
    for key in "${!tpl_params[@]}"; do
        local val="${tpl_params[$key]}"
        template="${template//\{\{.$key\}\}/$val}"
    done

    echo -e "${BOLD}Generated tasks:${NC}"
    echo ""
    echo "$template"
    echo ""
    echo -e "${YELLOW}提示: 将上述内容添加到 Taskfile.yml 的 tasks: 下${NC}"
}

# template 命令路由
cmd_template() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)  cmd_template_list "$@" ;;
        show)     cmd_template_show "$@" ;;
        use)      cmd_template_use "$@" ;;
        *)        die "未知 template 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# Plugin 插件命令
# -----------------------------------------------------------------------------

# 查找插件目录
find_plugin_dir() {
    local dirs=("$EZ_ROOT/plugins" "$HOME/.ez/plugins")
    for d in "${dirs[@]}"; do
        [[ -d "$d" ]] && echo "$d" && return 0
    done
    return 1
}

# plugin list - 列出已安装插件
cmd_plugin_list() {
    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    echo -e "${BOLD}Plugins in ${plugin_dir}:${NC}"
    echo ""

    for ptype in param hook template; do
        local type_dir="$plugin_dir/$ptype"
        [[ ! -d "$type_dir" ]] && continue

        local has_plugins=false
        for f in "$type_dir"/*.yml; do
            [[ ! -f "$f" ]] && continue
            has_plugins=true
            local name desc
            name=$("$YQ" eval '.name // ""' "$f")
            desc=$("$YQ" eval '.desc // ""' "$f")
            printf "  ${GREEN}%-20s${NC} ${CYAN}[%s]${NC} %s\n" "$name" "$ptype" "$desc"
        done
    done
}

# plugin show - 显示插件详情
cmd_plugin_show() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez plugin show <name>"

    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    # 在各类型目录中搜索
    local plugin_file=""
    for ptype in param hook template; do
        local f="$plugin_dir/$ptype/$name.yml"
        if [[ -f "$f" ]]; then
            plugin_file="$f"
            break
        fi
    done

    [[ -z "$plugin_file" ]] && die "插件未找到: $name"

    local pname ptype pdesc pversion
    pname=$("$YQ" eval '.name // ""' "$plugin_file")
    ptype=$("$YQ" eval '.type // ""' "$plugin_file")
    pdesc=$("$YQ" eval '.desc // ""' "$plugin_file")
    pversion=$("$YQ" eval '.version // ""' "$plugin_file")

    echo -e "${BOLD}Plugin: ${GREEN}$pname${NC}"
    echo -e "${BOLD}Type:${NC} $ptype"
    echo -e "${BOLD}Version:${NC} $pversion"
    echo ""
    echo -e "${BOLD}Description:${NC} $pdesc"
    echo ""
    echo -e "${BOLD}Script:${NC}"
    "$YQ" eval '.script' "$plugin_file" | sed 's/^/  /'
}

# plugin run - 运行插件脚本
cmd_plugin_run() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez plugin run <name>"

    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    local plugin_file=""
    for ptype in param hook template; do
        local f="$plugin_dir/$ptype/$name.yml"
        if [[ -f "$f" ]]; then
            plugin_file="$f"
            break
        fi
    done

    [[ -z "$plugin_file" ]] && die "插件未找到: $name"

    local script
    script=$("$YQ" eval '.script' "$plugin_file")
    eval "$script"
}

# plugin install - 从 URL 安装插件
cmd_plugin_install() {
    local url="${1:-}"
    [[ -z "$url" ]] && die "用法: ez plugin install <url>"

    local plugin_dir="$HOME/.ez/plugins"
    mkdir -p "$plugin_dir"/{param,hook,template}

    # 下载插件
    local tmp_file
    tmp_file=$(mktemp)
    echo "Downloading from $url..."
    if ! curl -sSL "$url" -o "$tmp_file"; then
        rm -f "$tmp_file"
        die "下载失败: $url"
    fi

    # 解析插件类型和名称
    local pname ptype
    pname=$("$YQ" eval '.name // ""' "$tmp_file")
    ptype=$("$YQ" eval '.type // ""' "$tmp_file")

    [[ -z "$pname" ]] && { rm -f "$tmp_file"; die "无效的插件文件: 缺少 name"; }
    [[ -z "$ptype" ]] && { rm -f "$tmp_file"; die "无效的插件文件: 缺少 type"; }

    local target_file="$plugin_dir/$ptype/$pname.yml"
    mv "$tmp_file" "$target_file"

    echo -e "${GREEN}✓ 插件已安装: $pname ($ptype)${NC}"
    echo "  位置: $target_file"
}

# plugin 命令路由
cmd_plugin() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)    cmd_plugin_list "$@" ;;
        show)       cmd_plugin_show "$@" ;;
        run)        cmd_plugin_run "$@" ;;
        install)    cmd_plugin_install "$@" ;;
        *)          die "未知 plugin 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# 命令: new (创建文件夹任务)
# -----------------------------------------------------------------------------
cmd_new() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez new <task-name>"

    local task_dir="$EZ_TASKS_DIR/$name"
    if [[ -d "$task_dir" ]]; then
        die "任务已存在: $task_dir"
    fi

    mkdir -p "$task_dir"

    # 创建 Taskfile.yml
    cat > "$task_dir/Taskfile.yml" << EOF
version: '3'

tasks:
  default:
    desc: "$name"
    cmds:
      - cmd: "echo 'TODO: implement $name'"
EOF

    # 创建 task.yml 元数据
    cat > "$task_dir/task.yml" << EOF
name: $name
version: "0.1"
desc: "$name task"

usage: |
  TODO: 描述此任务的用途和用法

params: []

tags: []
examples:
  - "ez $name"
EOF

    echo -e "${GREEN}✓ Task created: $task_dir/${NC}"
    echo "  Taskfile: $task_dir/Taskfile.yml"
    echo "  Metadata: $task_dir/task.yml"
}

# -----------------------------------------------------------------------------
# 命令: check (验证任务语法和依赖)
# -----------------------------------------------------------------------------
cmd_check() {
    local target="${1:-}"

    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    if [[ -z "$target" ]]; then
        # 验证所有任务
        echo -e "${BOLD}Checking all tasks...${NC}"
        echo ""

        local errors=0

        # 检查根 Taskfile 语法
        if "$YQ" eval '.' "$taskfile" &>/dev/null; then
            echo -e "  ${GREEN}✓${NC} $taskfile syntax OK"
        else
            echo -e "  ${RED}✗${NC} $taskfile syntax error"
            ((errors++))
        fi

        # 检查文件夹任务
        if [[ -d "$EZ_TASKS_DIR" ]]; then
            for dir in "$EZ_TASKS_DIR"/*/; do
                [[ ! -d "$dir" ]] && continue
                local tname
                tname=$(basename "$dir")
                local tfile=""
                [[ -f "$dir/Taskfile.yml" ]] && tfile="$dir/Taskfile.yml"
                [[ -f "$dir/Taskfile.yaml" ]] && tfile="$dir/Taskfile.yaml"

                if [[ -z "$tfile" ]]; then
                    echo -e "  ${RED}✗${NC} tasks/$tname: missing Taskfile.yml"
                    ((errors++))
                    continue
                fi

                if "$YQ" eval '.' "$tfile" &>/dev/null; then
                    echo -e "  ${GREEN}✓${NC} tasks/$tname OK"
                else
                    echo -e "  ${RED}✗${NC} tasks/$tname: syntax error"
                    ((errors++))
                fi
            done
        fi

        # 检查 ez-params 引用
        local tasks
        tasks=$(get_tasks "$taskfile")
        while IFS= read -r task; do
            [[ -z "$task" ]] && continue
            _check_task_refs "$taskfile" "$task" || ((errors++))
        done <<< "$tasks"

        echo ""
        if [[ $errors -eq 0 ]]; then
            echo -e "${GREEN}✓ All checks passed${NC}"
        else
            echo -e "${RED}✗ $errors error(s) found${NC}"
            return 1
        fi
    else
        # 验证单个任务
        echo -e "${BOLD}Checking task: $target${NC}"
        echo ""

        if is_folder_task "$target"; then
            local tfile="$EZ_TASKS_DIR/$target/Taskfile.yml"
            if "$YQ" eval '.' "$tfile" &>/dev/null; then
                echo -e "  ${GREEN}✓${NC} Taskfile syntax OK"
            else
                echo -e "  ${RED}✗${NC} Taskfile syntax error"
                return 1
            fi
        elif task_exists "$taskfile" "$target"; then
            echo -e "  ${GREEN}✓${NC} Task exists in $taskfile"
            _check_task_refs "$taskfile" "$target"
        else
            die "任务未找到: $target"
        fi
    fi
}

# 检查单个任务的引用完整性
_check_task_refs() {
    local taskfile="$1"
    local task="$2"
    local errors=0

    # 检查 ez-extends 目标是否存在
    if has_ez_extends "$taskfile" "$task"; then
        local base
        base=$(get_ez_extends "$taskfile" "$task")
        if task_exists "$taskfile" "$base"; then
            echo -e "  ${GREEN}✓${NC} $task extends $base (found)"
        else
            echo -e "  ${RED}✗${NC} $task extends $base (NOT FOUND)"
            ((errors++))
        fi
    fi

    # 检查 ez-compose 引用的任务是否存在
    if has_ez_compose "$taskfile" "$task"; then
        local compose_json
        compose_json=$(get_ez_compose_json "$taskfile" "$task")
        local count
        count=$(echo "$compose_json" | "$YQ" eval 'length' -)
        for ((i=0; i<count; i++)); do
            local ctask
            ctask=$(echo "$compose_json" | "$YQ" eval ".[$i].task" -)
            if task_exists "$taskfile" "$ctask"; then
                echo -e "  ${GREEN}✓${NC} $task compose[$i] → $ctask (found)"
            else
                echo -e "  ${RED}✗${NC} $task compose[$i] → $ctask (NOT FOUND)"
                ((errors++))
            fi
        done
    fi

    # 检查 ez-inputs 引用的产物来源
    if has_ez_inputs "$taskfile" "$task"; then
        local inputs_json
        inputs_json=$(get_ez_inputs_json "$taskfile" "$task")
        local count
        count=$(echo "$inputs_json" | "$YQ" eval 'length' -)
        for ((i=0; i<count; i++)); do
            local from_task
            from_task=$(echo "$inputs_json" | "$YQ" eval ".[$i].from" -)
            if task_exists "$taskfile" "$from_task"; then
                echo -e "  ${GREEN}✓${NC} $task input[$i] from $from_task (found)"
            else
                echo -e "  ${RED}✗${NC} $task input[$i] from $from_task (NOT FOUND)"
                ((errors++))
            fi
        done
    fi

    # 检查命令中的外部路径引用
    local cmds_text
    cmds_text=$("$YQ" eval ".tasks.\"$task\".cmds[].cmd // \"\"" "$taskfile" 2>/dev/null || true)
    if [[ -n "$cmds_text" ]]; then
        while IFS= read -r cmd_line; do
            [[ -z "$cmd_line" ]] && continue
            # 检测绝对路径引用
            local ext_path
            ext_path=$(echo "$cmd_line" | grep -oE '/[a-z][a-z0-9_/-]+' | head -1)
            if [[ -n "$ext_path" && "$ext_path" != "/dev/"* && "$ext_path" != "/tmp/"* && "$ext_path" != "/proc/"* ]]; then
                echo -e "  ${YELLOW}⚠${NC} $task 引用外部路径 $ext_path"
                echo -e "    ${DIM}该路径需要在执行节点上存在${NC}"
            fi
        done <<< "$cmds_text"
    fi

    return $errors
}

# -----------------------------------------------------------------------------
# 命令: completion (输出 Tab 补全脚本)
# -----------------------------------------------------------------------------
cmd_completion() {
    local shell="${1:-bash}"

    case "$shell" in
        bash)
            cat << 'COMPLETION_EOF'
# EZ bash completion
# Install: ez completion bash > ~/.bash_completion.d/ez && source ~/.bash_completion.d/ez
# Or: eval "$(ez completion bash)"

_ez_complete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case $COMP_CWORD in
        1)
            local cmds="list show new check browse plan template plugin log server client help version run completion"
            local tasks=$(_ez_task_names 2>/dev/null)
            COMPREPLY=($(compgen -W "$cmds $tasks" -- "$cur"))
            ;;
        2)
            case "$prev" in
                show|check|run)
                    COMPREPLY=($(compgen -W "$(_ez_task_names)" -- "$cur"))
                    ;;
                plan)
                    COMPREPLY=($(compgen -W "list new add show build check run $(_ez_plan_names)" -- "$cur"))
                    ;;
                template|tpl)
                    COMPREPLY=($(compgen -W "list show use" -- "$cur"))
                    ;;
                plugin)
                    COMPREPLY=($(compgen -W "list show run install" -- "$cur"))
                    ;;
                log)
                    COMPREPLY=($(compgen -W "list show clean" -- "$cur"))
                    ;;
                server)
                    COMPREPLY=($(compgen -W "start docker status" -- "$cur"))
                    ;;
                client)
                    COMPREPLY=($(compgen -W "start" -- "$cur"))
                    ;;
                completion)
                    COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
                    ;;
                new)
                    # 不补全，用户需要输入新名称
                    ;;
            esac
            ;;
        3)
            local pprev="${COMP_WORDS[COMP_CWORD-2]}"
            case "$pprev" in
                plan)
                    case "$prev" in
                        show|build|check|run)
                            COMPREPLY=($(compgen -W "$(_ez_plan_names)" -- "$cur"))
                            ;;
                        add)
                            COMPREPLY=($(compgen -W "$(_ez_plan_names)" -- "$cur"))
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac
}

_ez_task_names() {
    local ez_bin="${COMP_WORDS[0]}"
    "$ez_bin" list -f 2>/dev/null | awk '{print $1}'
}

_ez_plan_names() {
    local ez_bin="${COMP_WORDS[0]}"
    "$ez_bin" plan list 2>/dev/null | awk 'NF>0 && !/^Plans/ && !/^\(/ {print $1}'
}

complete -F _ez_complete ez
complete -F _ez_complete ./ez
COMPLETION_EOF
            ;;
        zsh)
            cat << 'COMPLETION_EOF'
# EZ zsh completion
# Install: ez completion zsh > ~/.zsh/completions/_ez
# Or: eval "$(ez completion zsh)"

_ez() {
    local -a commands tasks
    commands=(
        'list:列出任务'
        'show:显示任务详情'
        'run:运行任务'
        'new:创建文件夹任务'
        'check:验证任务'
        'browse:交互式浏览器'
        'plan:计划管理'
        'template:模板管理'
        'plugin:插件管理'
        'log:日志管理'
        'server:服务器管理'
        'client:客户端管理'
        'completion:输出补全脚本'
        'version:显示版本'
        'help:显示帮助'
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        tasks=(${(f)"$(./ez list -f 2>/dev/null | awk '{print $1}')"})
        [[ ${#tasks[@]} -gt 0 ]] && _describe 'task' tasks
    fi
}

compdef _ez ez
compdef _ez ./ez
COMPLETION_EOF
            ;;
        *)
            die "支持的 shell: bash, zsh"
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Server/Client 命令 (可选插件)
# -----------------------------------------------------------------------------

# 检查分布式功能是否可用
_check_distributed_available() {
    if ! command -v python3 &>/dev/null; then
        echo -e "${YELLOW}提示: 分布式功能需要 Python3${NC}"
        echo "  安装 Python3 后可使用 'ez server' 和 'ez client' 命令"
        echo ""
        echo "  EZ 仍可作为独立 CLI 工具使用:"
        echo "    ez list       - 列出任务"
        echo "    ez run <task> - 运行任务"
        echo "    ez plan run   - 执行计划"
        return 1
    fi
    return 0
}

# 安装 Python 依赖 (仅在需要时)
_install_server_deps() {
    local server_req="$EZ_ROOT/server/requirements.txt"
    if [[ -f "$server_req" ]]; then
        if ! python3 -c "import flask" 2>/dev/null; then
            echo -e "${YELLOW}安装 Server 依赖...${NC}"
            pip3 install -q -r "$server_req" || {
                echo -e "${RED}依赖安装失败，请手动运行: pip3 install -r server/requirements.txt${NC}"
                return 1
            }
        fi
    fi
    return 0
}

_install_client_deps() {
    if ! python3 -c "import socketio, requests" 2>/dev/null; then
        echo -e "${YELLOW}安装 Client 依赖...${NC}"
        pip3 install -q python-socketio requests || {
            echo -e "${RED}依赖安装失败，请手动运行: pip3 install python-socketio requests${NC}"
            return 1
        }
    fi
    return 0
}

# server start - 启动服务器
cmd_server_start() {
    _check_distributed_available || return 1
    _install_server_deps || return 1

    local port="${1:-8080}"

    echo -e "${BOLD}Starting EZ Server...${NC}"
    echo -e "  Port: ${GREEN}$port${NC}"
    echo -e "  Web UI: ${CYAN}http://localhost:$port${NC}"
    echo ""

    export EZ_ROOT="$EZ_ROOT"
    export EZ_HTTP_PORT="$port"

    python3 -m server.main
}

# server docker - 使用 Docker 启动
cmd_server_docker() {
    local action="${1:-up}"

    if ! command -v docker &>/dev/null; then
        die "Docker 未安装"
    fi

    if [[ ! -f "$EZ_ROOT/server/docker-compose.yml" ]]; then
        die "server/docker-compose.yml 未找到"
    fi

    case "$action" in
        up)
            echo -e "${BOLD}Starting EZ Server (Docker)...${NC}"
            docker-compose -f "$EZ_ROOT/server/docker-compose.yml" up -d
            echo -e "${GREEN}✓ Server started at http://localhost:8080${NC}"
            ;;
        down)
            docker-compose -f "$EZ_ROOT/server/docker-compose.yml" down
            echo -e "${GREEN}✓ Server stopped${NC}"
            ;;
        logs)
            docker-compose -f "$EZ_ROOT/server/docker-compose.yml" logs -f
            ;;
        build)
            docker-compose -f "$EZ_ROOT/server/docker-compose.yml" build
            ;;
        *)
            die "用法: ez server docker [up|down|logs|build]"
            ;;
    esac
}

# server status - 显示状态信息
cmd_server_status() {
    echo -e "${BOLD}EZ 分布式功能状态:${NC}"
    echo ""

    # Python
    if command -v python3 &>/dev/null; then
        echo -e "  Python3: ${GREEN}✓ $(python3 --version 2>&1)${NC}"
    else
        echo -e "  Python3: ${RED}✗ 未安装${NC}"
    fi

    # Flask
    if python3 -c "import flask" 2>/dev/null; then
        echo -e "  Flask:   ${GREEN}✓ 已安装${NC}"
    else
        echo -e "  Flask:   ${YELLOW}○ 未安装 (pip3 install flask)${NC}"
    fi

    # Docker
    if command -v docker &>/dev/null; then
        echo -e "  Docker:  ${GREEN}✓ 可用${NC}"
    else
        echo -e "  Docker:  ${DIM}○ 未安装 (可选)${NC}"
    fi

    echo ""
    echo -e "${DIM}提示: 分布式功能为可选，EZ 可独立使用${NC}"
}

# server 命令路由
cmd_server() {
    local subcmd="${1:-status}"
    shift || true

    case "$subcmd" in
        start)    cmd_server_start "$@" ;;
        docker)   cmd_server_docker "$@" ;;
        status)   cmd_server_status "$@" ;;
        *)        die "未知 server 子命令: $subcmd，可用: start, docker, status" ;;
    esac
}

# client start - 启动客户端代理
cmd_client_start() {
    _check_distributed_available || return 1
    _install_client_deps || return 1

    local server_url="${1:-http://localhost:8080}"
    local node_name="${2:-$(hostname)-$$}"

    echo -e "${BOLD}Starting EZ Client Agent...${NC}"
    echo -e "  Server: ${GREEN}$server_url${NC}"
    echo -e "  Node:   ${CYAN}$node_name${NC}"
    echo ""

    export EZ_ROOT="$EZ_ROOT"
    export EZ_SERVER_URL="$server_url"
    export EZ_NODE_NAME="$node_name"

    python3 "$EZ_ROOT/server/client/agent.py" --server="$server_url" --name="$node_name"
}

# client 命令路由
cmd_client() {
    local subcmd="${1:-start}"
    shift || true

    case "$subcmd" in
        start)    cmd_client_start "$@" ;;
        *)        die "未知 client 子命令: $subcmd，可用: start" ;;
    esac
}

# -----------------------------------------------------------------------------
# 命令: export/import (文件夹任务管理)
# -----------------------------------------------------------------------------
cmd_folder_list() {
    if [[ ! -d "$EZ_TASKS_DIR" ]] || [[ -z "$(ls -A "$EZ_TASKS_DIR" 2>/dev/null)" ]]; then
        echo "  (无文件夹任务)"
        echo -e "  ${DIM}提示: ez new <name> 创建新文件夹任务${NC}"
        return
    fi

    echo -e "${BOLD}Folder Tasks:${NC}"
    echo ""
    for dir in "$EZ_TASKS_DIR"/*/; do
        [[ ! -d "$dir" ]] && continue
        local name desc=""
        name=$(basename "$dir")
        if [[ -f "$dir/task.yml" ]]; then
            desc=$("$YQ" eval '.desc // ""' "$dir/task.yml" 2>/dev/null)
        elif [[ -f "$dir/Taskfile.yml" ]]; then
            desc=$(get_task_prop "$dir/Taskfile.yml" "default" "desc" 2>/dev/null || true)
        fi
        printf "  ${GREEN}%-25s${NC} %s\n" "$name" "$desc"
    done
}

cmd_folder_show() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez export <name>"
    cmd_show "$name"
}

cmd_export() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez export <name>"

    local task_dir="$EZ_TASKS_DIR/$name"
    [[ -d "$task_dir" ]] || die "任务未找到: $name"

    local output="${name}.tar.gz"
    tar -czf "$output" -C "$EZ_TASKS_DIR" "$name"
    echo -e "${GREEN}✓ Exported: $output${NC}"
}

cmd_import() {
    local path="${1:-}"
    [[ -z "$path" ]] && die "用法: ez import <path.tar.gz>"
    [[ -f "$path" ]] || die "文件不存在: $path"

    mkdir -p "$EZ_TASKS_DIR"
    tar -xzf "$path" -C "$EZ_TASKS_DIR"

    local imported
    imported=$(tar -tzf "$path" | head -1 | cut -d/ -f1)
    echo -e "${GREEN}✓ Imported: tasks/$imported/${NC}"
}

cmd_folder_manage() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)    cmd_folder_list "$@" ;;
        show)       cmd_folder_show "$@" ;;
        export)     cmd_export "$@" ;;
        import)     cmd_import "$@" ;;
        *)          die "未知子命令: $subcmd，可用: list, show, export, import" ;;
    esac
}

# -----------------------------------------------------------------------------
# 命令: clean (清理运行时数据)
# -----------------------------------------------------------------------------
cmd_clean() {
    local target="${1:-}"

    if [[ -z "$target" ]]; then
        die "用法: ez clean <name> | --all | --logs | --workspace"
    fi

    case "$target" in
        --all)
            rm -rf "$EZ_DIR"
            echo -e "${GREEN}✓ Cleaned: .ez/ (all runtime data)${NC}"
            ;;
        --logs)
            rm -rf "$EZ_DIR"/tasks/*/logs "$EZ_DIR"/plans/*/logs "$EZ_LOG_DIR"
            echo -e "${GREEN}✓ Cleaned: all logs${NC}"
            ;;
        --workspace)
            rm -rf "$EZ_DIR"/tasks/*/workspace "$EZ_WORKSPACE_DIR"
            echo -e "${GREEN}✓ Cleaned: all workspaces${NC}"
            ;;
        *)
            # 尝试清理 task 或 plan
            if [[ -d "$EZ_DIR/tasks/$target" ]]; then
                rm -rf "$EZ_DIR/tasks/$target"
                echo -e "${GREEN}✓ Cleaned: .ez/tasks/$target/${NC}"
            elif [[ -d "$EZ_DIR/plans/$target" ]]; then
                rm -rf "$EZ_DIR/plans/$target"
                echo -e "${GREEN}✓ Cleaned: .ez/plans/$target/${NC}"
            else
                echo -e "${YELLOW}Nothing to clean for: $target${NC}"
            fi
            ;;
    esac
}

# -----------------------------------------------------------------------------
# 主入口
# -----------------------------------------------------------------------------
main() {
    ensure_deps

    local cmd="${1:-list}"  # 无参数默认 list
    shift || true

    case "$cmd" in
        list|ls)      cmd_list "$@" ;;
        browse)       cmd_browse "$@" ;;
        show|describe) cmd_show "$@" ;;
        run|exec)     cmd_run "$@" ;;
        new)          cmd_new "$@" ;;
        check)        cmd_check "$@" ;;
        clean)        cmd_clean "$@" ;;
        export)       cmd_export "$@" ;;
        import)       cmd_import "$@" ;;
        completion)   cmd_completion "$@" ;;
        plan)         cmd_plan "$@" ;;
        template|tpl) cmd_template "$@" ;;
        plugin)       cmd_plugin "$@" ;;
        log)          cmd_log "$@" ;;
        server)       cmd_server "$@" ;;
        client)       cmd_client "$@" ;;
        version|-v|--version)   cmd_version ;;
        help|-h|--help)         cmd_help ;;
        *)
            # 尝试作为 task 名直接执行 (implicit run)
            local taskfile
            if taskfile=$(find_taskfile ".") && task_exists "$taskfile" "$cmd"; then
                cmd_run "$cmd" "$@"
            else
                die "未知命令或任务: $cmd\n  提示: ez list 查看可用任务, ez help 查看帮助"
            fi
            ;;
    esac
}

main "$@"
