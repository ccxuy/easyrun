#!/usr/bin/env bash
#
# EZ - go-task 智能前端
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/ez-core.sh"

# -----------------------------------------------------------------------------
# 命令: version
# -----------------------------------------------------------------------------
cmd_version() {
    echo "ez version $EZ_VERSION"
    echo ""
    echo "Dependencies:"
    echo "  yq:   $("$YQ" --version 2>/dev/null | head -1)"
    echo "  task: $("$TASK" --version 2>/dev/null | head -1)"
}

# -----------------------------------------------------------------------------
# 命令: help
# -----------------------------------------------------------------------------
cmd_help() {
    cat << 'EOF'
EZ - go-task 智能前端

用法:
    ez <command> [options] [args]

命令:
    list                列出所有任务
    show <task>         显示任务详情
    run <task>          运行任务（交互式参数）
    plan list           列出所有计划
    plan show <plan>    显示计划详情
    plan run <plan>     执行计划
    template list       列出可用模板
    template show <tpl> 显示模板详情
    template use <tpl>  使用模板生成任务
    plugin list         列出已安装插件
    plugin show <name>  显示插件详情
    plugin run <name>   运行插件脚本
    plugin install <url> 从 URL 安装插件
    version             显示版本信息
    help                显示帮助

选项:
    --dry-run           只显示命令，不执行
    --resume            恢复中断的计划

示例:
    ez list
    ez show build
    ez run build
    ez run build --dry-run
    ez plan list
    ez plan run kernel-ci
    ez template list
    ez template use kernel-build --name=mykernel
    ez plugin list
EOF
}

# -----------------------------------------------------------------------------
# 命令: list
# -----------------------------------------------------------------------------
cmd_list() {
    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    echo -e "${BOLD}Tasks in ${taskfile}:${NC}"
    echo ""

    local tasks
    tasks=$(get_tasks "$taskfile")

    if [[ -z "$tasks" ]]; then
        echo "  (无任务)"
        return
    fi

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        local desc param_flag=""
        desc=$(get_task_prop "$taskfile" "$name" "desc")
        has_ez_params "$taskfile" "$name" && param_flag=" ${CYAN}[params]${NC}"
        printf "  ${GREEN}%-20s${NC} %s%s\n" "$name" "$desc" "$param_flag"
    done <<< "$tasks"
}

# -----------------------------------------------------------------------------
# 命令: show
# -----------------------------------------------------------------------------
cmd_show() {
    local task="${1:-}"
    [[ -z "$task" ]] && die "用法: ez show <task>"

    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 检查任务是否存在
    local exists
    exists=$("$YQ" eval ".tasks.\"$task\" // \"\"" "$taskfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "任务未找到: $task"

    echo -e "${BOLD}Task: ${GREEN}$task${NC}"
    echo ""

    # 描述
    local desc
    desc=$(get_task_prop "$taskfile" "$task" "desc")
    [[ -n "$desc" ]] && echo -e "${BOLD}Description:${NC} $desc" && echo ""

    # 命令
    echo -e "${BOLD}Commands:${NC}"
    "$YQ" eval ".tasks.\"$task\".cmds[].cmd // .tasks.\"$task\".cmds[]" "$taskfile" 2>/dev/null | while IFS= read -r cmd; do
        [[ -n "$cmd" ]] && echo "  - $cmd"
    done
    echo ""

    # EZ 参数
    if has_ez_params "$taskfile" "$task"; then
        echo -e "${BOLD}Parameters:${NC}"
        local params_json
        params_json=$(get_ez_params_json "$taskfile" "$task")
        local count
        count=$(echo "$params_json" | "$YQ" eval 'length' -)

        for ((i=0; i<count; i++)); do
            local pname ptype pdefault phelp poptions query_cmd query_url
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            ptype=$(echo "$params_json" | "$YQ" eval ".[$i].type // \"input\"" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
            phelp=$(echo "$params_json" | "$YQ" eval ".[$i].help // \"\"" -)
            query_cmd=$(echo "$params_json" | "$YQ" eval ".[$i].query.command // \"\"" -)
            query_url=$(echo "$params_json" | "$YQ" eval ".[$i].query.url // \"\"" -)

            # 变量名
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"

            echo ""
            echo -e "  ${CYAN}$pname${NC} ${YELLOW}($ptype)${NC} → ${GREEN}\${{.$varname}}${NC}"

            # 帮助信息（支持多行）
            if [[ -n "$phelp" && "$phelp" != "null" ]]; then
                echo "$phelp" | while IFS= read -r line; do
                    echo -e "    ${BLUE}$line${NC}"
                done
            fi

            # 默认值
            [[ -n "$pdefault" && "$pdefault" != "null" ]] && echo -e "    Default: ${GREEN}$pdefault${NC}"

            # 静态选项
            if [[ "$ptype" == "select" ]]; then
                poptions=$(echo "$params_json" | "$YQ" eval ".[$i].options | join(\", \")" - 2>/dev/null || true)
                [[ -n "$poptions" && "$poptions" != "null" ]] && echo -e "    Options: $poptions"
            fi

            # 动态查询
            if [[ -n "$query_cmd" && "$query_cmd" != "null" ]]; then
                echo -e "    Source: ${CYAN}command${NC} → $query_cmd"
            elif [[ -n "$query_url" && "$query_url" != "null" ]]; then
                local query_jq
                query_jq=$(echo "$params_json" | "$YQ" eval ".[$i].query.jq // \"\"" -)
                echo -e "    Source: ${CYAN}url${NC} → $query_url"
                [[ -n "$query_jq" && "$query_jq" != "null" ]] && echo -e "    Filter: $query_jq"
            fi
        done
        echo ""

        # 使用示例
        echo -e "${BOLD}Usage:${NC}"
        echo -e "  ./ez run $task"
        local example_vars=""
        for ((i=0; i<count; i++)); do
            local pname pdefault
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"value\"" -)
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"
            example_vars+=" $varname=$pdefault"
        done
        echo -e "  ./ez run $task$example_vars"
    fi
}

# -----------------------------------------------------------------------------
# 交互式参数选择
# -----------------------------------------------------------------------------
select_value() {
    local name="$1" type="$2" options_json="$3" default="$4" help="$5"

    # 所有交互输出到 stderr，只有结果输出到 stdout
    echo -e "${BOLD}$name${NC}" >&2
    [[ -n "$help" && "$help" != "null" ]] && echo -e "  ${CYAN}$help${NC}" >&2

    if [[ "$type" == "select" ]]; then
        local opts=()
        while IFS= read -r opt; do
            [[ -n "$opt" ]] && opts+=("$opt")
        done < <(echo "$options_json" | "$YQ" eval '.[]' - 2>/dev/null)

        if [[ ${#opts[@]} -gt 0 ]]; then
            local i=1
            for opt in "${opts[@]}"; do
                local marker=""
                [[ "$opt" == "$default" ]] && marker=" (default)"
                echo "    $i) $opt$marker" >&2
                ((i++))
            done

            while true; do
                read -rp "  Choice [1-${#opts[@]}]: " choice </dev/tty
                # 回车使用默认值
                if [[ -z "$choice" && -n "$default" ]]; then
                    echo "$default"
                    return
                fi
                if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#opts[@]})); then
                    echo "${opts[$((choice-1))]}"
                    return
                fi
                echo "  无效选择，请重试" >&2
            done
        fi
    fi

    # input 类型或其他
    read -rp "  Value [$default]: " value </dev/tty
    echo "${value:-$default}"
}

# -----------------------------------------------------------------------------
# 命令: run
# -----------------------------------------------------------------------------
cmd_run() {
    local task="${1:-}"
    shift || true
    [[ -z "$task" ]] && die "用法: ez run <task> [options]"

    local taskfile dry_run=false
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 解析选项
    local -a extra_vars=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run) dry_run=true; shift ;;
            *=*) extra_vars+=("$1"); shift ;;
            *) shift ;;
        esac
    done

    # 收集 ez-params 参数（交互式）
    if has_ez_params "$taskfile" "$task"; then
        echo -e "${BOLD}Configure: ${GREEN}$task${NC}"
        echo ""

        local params_json
        params_json=$(get_ez_params_json "$taskfile" "$task")
        local count
        count=$(echo "$params_json" | "$YQ" eval 'length' -)

        for ((i=0; i<count; i++)); do
            local pname ptype poptions pdefault phelp value
            pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
            ptype=$(echo "$params_json" | "$YQ" eval ".[$i].type // \"input\"" -)
            poptions=$(echo "$params_json" | "$YQ" eval -o=json ".[$i].options // []" -)
            pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
            phelp=$(echo "$params_json" | "$YQ" eval ".[$i].help // \"\"" -)

            # 检查是否已预设
            local varname="EZ_$(echo "$pname" | tr '[:lower:]-' '[:upper:]_')"
            local preset=""
            for v in "${extra_vars[@]}"; do
                [[ "$v" == "$varname="* ]] && preset="${v#*=}"
            done

            if [[ -n "$preset" ]]; then
                echo -e "${BOLD}$pname${NC}: $preset (preset)"
                value="$preset"
            else
                # 检查 query.command 动态获取选项
                local query_cmd query_url query_jq
                query_cmd=$(echo "$params_json" | "$YQ" eval ".[$i].query.command // \"\"" -)
                query_url=$(echo "$params_json" | "$YQ" eval ".[$i].query.url // \"\"" -)
                query_jq=$(echo "$params_json" | "$YQ" eval ".[$i].query.jq // \"\"" -)

                if [[ -n "$query_cmd" && "$query_cmd" != "null" && ("$poptions" == "[]" || "$poptions" == "null") ]]; then
                    echo -e "  ${CYAN}(query: $query_cmd)${NC}" >&2
                    local cmd_output
                    if cmd_output=$(eval "$query_cmd" 2>/dev/null); then
                        poptions=$(echo "$cmd_output" | "$YQ" -o=json -I0 'split("\n") | map(select(. != ""))')
                    fi
                elif [[ -n "$query_url" && "$query_url" != "null" && ("$poptions" == "[]" || "$poptions" == "null") ]]; then
                    echo -e "  ${CYAN}(fetch: $query_url)${NC}" >&2
                    local url_output
                    if url_output=$(curl -fsSL "$query_url" 2>/dev/null); then
                        if [[ -n "$query_jq" && "$query_jq" != "null" ]]; then
                            # 使用 jq 表达式提取数据
                            poptions=$(echo "$url_output" | "$YQ" -o=json "$query_jq")
                        else
                            # 假设返回的是每行一个选项
                            poptions=$(echo "$url_output" | "$YQ" -o=json -I0 'split("\n") | map(select(. != ""))')
                        fi
                    fi
                fi

                value=$(select_value "$pname" "$ptype" "$poptions" "$pdefault" "$phelp")
                extra_vars+=("$varname=$value")
            fi
            echo ""
        done
    fi

    # 构建命令
    local -a cmd=("$TASK" "-t" "$taskfile" "$task")
    for v in "${extra_vars[@]}"; do
        cmd+=("$v")
    done

    if $dry_run; then
        echo -e "${BOLD}Dry run:${NC} ${cmd[*]}"
        return 0
    fi

    # pre_run 钩子
    run_hooks "$taskfile" "$task" "pre_run" 0 ""

    echo -e "${BOLD}Running:${NC} ${cmd[*]}"
    echo ""

    # 执行任务并捕获输出和退出码
    local task_output exit_code=0
    task_output=$("${cmd[@]}" 2>&1) || exit_code=$?
    echo "$task_output"

    # post_run 或 on_error 钩子
    if [[ $exit_code -eq 0 ]]; then
        run_hooks "$taskfile" "$task" "post_run" "$exit_code" "$task_output"
    else
        run_hooks "$taskfile" "$task" "on_error" "$exit_code" "$task_output"
        return $exit_code
    fi
}

# -----------------------------------------------------------------------------
# Plan 计划相关函数
# -----------------------------------------------------------------------------
PLAN_FILE=".ez-plan.yml"

find_planfile() {
    [[ -f "$PLAN_FILE" ]] && echo "$PLAN_FILE" && return 0
    [[ -f ".ez-plan.yaml" ]] && echo ".ez-plan.yaml" && return 0
    return 1
}

# plan list - 列出所有计划
cmd_plan_list() {
    local planfile
    planfile=$(find_planfile) || die "未找到计划文件 (.ez-plan.yml)"

    echo -e "${BOLD}Plans in ${planfile}:${NC}"
    echo ""

    local plans
    plans=$("$YQ" eval '.plans | keys | .[]' "$planfile" 2>/dev/null)

    if [[ -z "$plans" ]]; then
        echo "  (无计划)"
        return
    fi

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        local desc step_count
        desc=$("$YQ" eval ".plans.\"$name\".desc // \"\"" "$planfile")
        step_count=$("$YQ" eval ".plans.\"$name\".steps | length" "$planfile")
        printf "  ${GREEN}%-20s${NC} %s ${CYAN}[%s steps]${NC}\n" "$name" "$desc" "$step_count"
    done <<< "$plans"
}

# plan show - 显示计划详情
cmd_plan_show() {
    local plan="${1:-}"
    [[ -z "$plan" ]] && die "用法: ez plan show <plan>"

    local planfile
    planfile=$(find_planfile) || die "未找到计划文件"

    local exists
    exists=$("$YQ" eval ".plans.\"$plan\" // \"\"" "$planfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "计划未找到: $plan"

    echo -e "${BOLD}Plan: ${GREEN}$plan${NC}"
    echo ""

    local desc
    desc=$("$YQ" eval ".plans.\"$plan\".desc // \"\"" "$planfile")
    [[ -n "$desc" ]] && echo -e "${BOLD}Description:${NC} $desc" && echo ""

    echo -e "${BOLD}Steps:${NC}"
    local steps_json
    steps_json=$("$YQ" eval -o=json ".plans.\"$plan\".steps // []" "$planfile")
    local step_count
    step_count=$(echo "$steps_json" | "$YQ" eval 'length' -)

    for ((i=0; i<step_count; i++)); do
        local sname stask scheckpoint smatrix
        sname=$(echo "$steps_json" | "$YQ" eval ".[$i].name // \"step-$i\"" -)
        stask=$(echo "$steps_json" | "$YQ" eval ".[$i].task // \"\"" -)
        scheckpoint=$(echo "$steps_json" | "$YQ" eval ".[$i].checkpoint // false" -)
        smatrix=$(echo "$steps_json" | "$YQ" eval ".[$i].matrix // \"\"" -)

        local step_num=$((i+1))
        if [[ "$scheckpoint" == "true" ]]; then
            local prompt
            prompt=$(echo "$steps_json" | "$YQ" eval ".[$i].prompt // \"Continue?\"" -)
            echo -e "  ${YELLOW}$step_num. ⏸ $sname${NC} (checkpoint)"
            echo -e "     ${CYAN}$prompt${NC}"
        elif [[ -n "$smatrix" && "$smatrix" != "null" ]]; then
            echo -e "  ${CYAN}$step_num. $sname${NC} → task:$stask [matrix]"
        else
            echo -e "  ${CYAN}$step_num. $sname${NC} → task:$stask"
        fi
    done
}

# plan run - 执行计划
cmd_plan_run() {
    local plan="${1:-}"
    shift || true
    [[ -z "$plan" ]] && die "用法: ez plan run <plan> [--dry-run] [--resume]"

    local planfile dry_run=false resume=false
    planfile=$(find_planfile) || die "未找到计划文件"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run) dry_run=true; shift ;;
            --resume) resume=true; shift ;;
            *) shift ;;
        esac
    done

    local exists
    exists=$("$YQ" eval ".plans.\"$plan\" // \"\"" "$planfile")
    [[ -z "$exists" || "$exists" == "null" ]] && die "计划未找到: $plan"

    local taskfile
    taskfile=$(find_taskfile ".") || die "未找到 Taskfile"

    # 状态文件
    local state_dir=".ez-state"
    local state_file="$state_dir/$plan.state"
    mkdir -p "$state_dir"

    local start_step=0
    if $resume && [[ -f "$state_file" ]]; then
        start_step=$(cat "$state_file")
        echo -e "${YELLOW}⏩ 从步骤 $((start_step+1)) 恢复${NC}"
    fi

    echo -e "${BOLD}========================================${NC}"
    echo -e "${BOLD}Plan: ${GREEN}$plan${NC}"
    echo -e "${BOLD}========================================${NC}"
    echo ""

    local steps_json
    steps_json=$("$YQ" eval -o=json ".plans.\"$plan\".steps // []" "$planfile")
    local step_count
    step_count=$(echo "$steps_json" | "$YQ" eval 'length' -)

    for ((i=start_step; i<step_count; i++)); do
        local sname stask scheckpoint smatrix svars sprompt swhen
        sname=$(echo "$steps_json" | "$YQ" eval ".[$i].name // \"step-$i\"" -)
        stask=$(echo "$steps_json" | "$YQ" eval ".[$i].task // \"\"" -)
        scheckpoint=$(echo "$steps_json" | "$YQ" eval ".[$i].checkpoint // false" -)
        smatrix=$(echo "$steps_json" | "$YQ" eval -o=json ".[$i].matrix // null" -)
        svars=$(echo "$steps_json" | "$YQ" eval -o=json ".[$i].vars // {}" -)
        swhen=$(echo "$steps_json" | "$YQ" eval ".[$i].when // \"\"" -)

        local step_num=$((i+1))

        # when 条件检查
        if [[ -n "$swhen" && "$swhen" != "null" ]]; then
            local env_var
            env_var=$(echo "$swhen" | sed -n 's/.*env\.\([A-Za-z_][A-Za-z0-9_]*\).*/\1/p')
            if [[ -n "$env_var" ]]; then
                local env_val="${!env_var:-}"
                if [[ -z "$env_val" || "$env_val" == "false" || "$env_val" == "0" ]]; then
                    echo -e "${DIM}[$step_num/$step_count] $sname (skipped: $env_var not set)${NC}"
                    echo ""
                    continue
                fi
            fi
        fi

        echo -e "${BOLD}[$step_num/$step_count] $sname${NC}"

        # 保存状态
        if ! $dry_run; then
            echo "$i" > "$state_file"
        fi

        # 检查点
        if [[ "$scheckpoint" == "true" ]]; then
            sprompt=$(echo "$steps_json" | "$YQ" eval ".[$i].prompt // \"Continue?\"" -)
            echo -e "${YELLOW}⏸ Checkpoint: $sprompt${NC}"
            if ! $dry_run; then
                read -rp "  Press Enter to continue, or Ctrl+C to abort..." </dev/tty
            fi
            echo ""
            continue
        fi

        # 矩阵执行
        if [[ "$smatrix" != "null" ]]; then
            _run_matrix_step "$taskfile" "$stask" "$smatrix" "$svars" "$dry_run"
            echo ""
            continue
        fi

        # 普通任务
        local -a task_vars=()
        if [[ "$svars" != "{}" && "$svars" != "null" ]]; then
            while IFS= read -r key; do
                [[ -z "$key" ]] && continue
                local val
                val=$(echo "$svars" | "$YQ" eval ".$key" -)
                task_vars+=("$key=$val")
            done < <(echo "$svars" | "$YQ" eval 'keys | .[]' -)
        fi

        if $dry_run; then
            echo "  [dry-run] $TASK -t $taskfile $stask ${task_vars[*]}"
        else
            "$TASK" -t "$taskfile" "$stask" "${task_vars[@]}"
        fi
        echo ""
    done

    # 完成后删除状态文件
    rm -f "$state_file"

    echo -e "${BOLD}========================================${NC}"
    echo -e "${GREEN}✓ Plan completed: $plan${NC}"
    echo -e "${BOLD}========================================${NC}"
}

# 矩阵步骤执行 (支持多维)
_run_matrix_step() {
    local taskfile="$1" stask="$2" smatrix="$3" svars="$4" dry_run="$5"

    local matrix_keys
    matrix_keys=$(echo "$smatrix" | "$YQ" eval 'keys | .[]' -)
    local key_array=()
    while IFS= read -r k; do
        [[ -n "$k" ]] && key_array+=("$k")
    done <<< "$matrix_keys"

    if [[ ${#key_array[@]} -eq 1 ]]; then
        local key="${key_array[0]}"
        local values
        values=$(echo "$smatrix" | "$YQ" eval ".$key[]" -)
        while IFS= read -r val; do
            [[ -z "$val" ]] && continue
            _run_matrix_task "$taskfile" "$stask" "$svars" "$key" "$val" "" "" "$dry_run"
        done <<< "$values"
    elif [[ ${#key_array[@]} -ge 2 ]]; then
        local key1="${key_array[0]}" key2="${key_array[1]}"
        local values1 values2
        values1=$(echo "$smatrix" | "$YQ" eval ".$key1[]" -)
        values2=$(echo "$smatrix" | "$YQ" eval ".$key2[]" -)
        while IFS= read -r v1; do
            [[ -z "$v1" ]] && continue
            while IFS= read -r v2; do
                [[ -z "$v2" ]] && continue
                _run_matrix_task "$taskfile" "$stask" "$svars" "$key1" "$v1" "$key2" "$v2" "$dry_run"
            done <<< "$values2"
        done <<< "$values1"
    fi
}

# 执行单个矩阵任务
_run_matrix_task() {
    local taskfile="$1" stask="$2" svars="$3"
    local key1="$4" val1="$5" key2="$6" val2="$7" dry_run="$8"

    local -a task_vars=()
    local label="$key1=$val1"
    [[ -n "$key2" ]] && label="$key1=$val1, $key2=$val2"

    if [[ "$svars" != "{}" && "$svars" != "null" ]]; then
        while IFS= read -r vkey; do
            [[ -z "$vkey" ]] && continue
            local vval
            vval=$(echo "$svars" | "$YQ" eval ".$vkey" -)
            vval="${vval//\{\{.${key1}\}\}/$val1}"
            [[ -n "$key2" ]] && vval="${vval//\{\{.${key2}\}\}/$val2}"
            task_vars+=("$vkey=$vval")
        done < <(echo "$svars" | "$YQ" eval 'keys | .[]' -)
    fi

    echo -e "  ${CYAN}→ $stask ($label)${NC}"
    if [[ "$dry_run" == "true" ]]; then
        echo "    [dry-run] $TASK -t $taskfile $stask ${task_vars[*]}"
    else
        "$TASK" -t "$taskfile" "$stask" "${task_vars[@]}"
    fi
}

# plan 命令路由
cmd_plan() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)  cmd_plan_list "$@" ;;
        show)     cmd_plan_show "$@" ;;
        run)      cmd_plan_run "$@" ;;
        *)        die "未知 plan 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# Template 模板命令
# -----------------------------------------------------------------------------

# 查找模板目录
find_template_dir() {
    local dirs=("$EZ_ROOT/templates" "$HOME/.ez/templates")
    for d in "${dirs[@]}"; do
        [[ -d "$d" ]] && echo "$d" && return 0
    done
    return 1
}

# template list - 列出可用模板
cmd_template_list() {
    local tpl_dir
    tpl_dir=$(find_template_dir) || die "未找到模板目录"

    echo -e "${BOLD}Templates in ${tpl_dir}:${NC}"
    echo ""

    for f in "$tpl_dir"/*.yml; do
        [[ ! -f "$f" ]] && continue
        local name desc
        name=$("$YQ" eval '.name // ""' "$f")
        desc=$("$YQ" eval '.desc // ""' "$f")
        printf "  ${GREEN}%-20s${NC} %s\n" "$name" "$desc"
    done
}

# template show - 显示模板详情
cmd_template_show() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez template show <name>"

    local tpl_dir tpl_file
    tpl_dir=$(find_template_dir) || die "未找到模板目录"
    tpl_file="$tpl_dir/$name.yml"
    [[ ! -f "$tpl_file" ]] && die "模板未找到: $name"

    local desc version
    desc=$("$YQ" eval '.desc // ""' "$tpl_file")
    version=$("$YQ" eval '.version // ""' "$tpl_file")

    echo -e "${BOLD}Template: ${GREEN}$name${NC}"
    echo -e "${BOLD}Version:${NC} $version"
    echo ""
    echo -e "${BOLD}Description:${NC} $desc"
    echo ""
    echo -e "${BOLD}Parameters:${NC}"

    local params_json
    params_json=$("$YQ" eval -o=json '.params // []' "$tpl_file")
    local param_count
    param_count=$(echo "$params_json" | "$YQ" eval 'length' -)

    for ((i=0; i<param_count; i++)); do
        local pname pdesc pdefault
        pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
        pdesc=$(echo "$params_json" | "$YQ" eval ".[$i].desc // \"\"" -)
        pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
        echo -e "  ${CYAN}$pname${NC}"
        echo "    $pdesc"
        echo -e "    Default: ${GREEN}$pdefault${NC}"
    done

    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  ez template use $name --name=myproject"
}

# template use - 使用模板生成任务
cmd_template_use() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez template use <name> [--param=value ...]"
    shift || true

    local tpl_dir tpl_file
    tpl_dir=$(find_template_dir) || die "未找到模板目录"
    tpl_file="$tpl_dir/$name.yml"
    [[ ! -f "$tpl_file" ]] && die "模板未找到: $name"

    # 解析参数
    declare -A tpl_params
    local params_json
    params_json=$("$YQ" eval -o=json '.params // []' "$tpl_file")
    local param_count
    param_count=$(echo "$params_json" | "$YQ" eval 'length' -)

    # 加载默认值
    for ((i=0; i<param_count; i++)); do
        local pname pdefault
        pname=$(echo "$params_json" | "$YQ" eval ".[$i].name" -)
        pdefault=$(echo "$params_json" | "$YQ" eval ".[$i].default // \"\"" -)
        tpl_params["$pname"]="$pdefault"
    done

    # 覆盖命令行参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*=*)
                local key="${1%%=*}"
                key="${key#--}"
                local val="${1#*=}"
                tpl_params["$key"]="$val"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # 读取模板内容
    local template
    template=$("$YQ" eval '.template' "$tpl_file")

    # 替换模板变量
    for key in "${!tpl_params[@]}"; do
        local val="${tpl_params[$key]}"
        template="${template//\{\{.$key\}\}/$val}"
    done

    echo -e "${BOLD}Generated tasks:${NC}"
    echo ""
    echo "$template"
    echo ""
    echo -e "${YELLOW}提示: 将上述内容添加到 Taskfile.yml 的 tasks: 下${NC}"
}

# template 命令路由
cmd_template() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)  cmd_template_list "$@" ;;
        show)     cmd_template_show "$@" ;;
        use)      cmd_template_use "$@" ;;
        *)        die "未知 template 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# Plugin 插件命令
# -----------------------------------------------------------------------------

# 查找插件目录
find_plugin_dir() {
    local dirs=("$EZ_ROOT/plugins" "$HOME/.ez/plugins")
    for d in "${dirs[@]}"; do
        [[ -d "$d" ]] && echo "$d" && return 0
    done
    return 1
}

# plugin list - 列出已安装插件
cmd_plugin_list() {
    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    echo -e "${BOLD}Plugins in ${plugin_dir}:${NC}"
    echo ""

    for ptype in param hook template; do
        local type_dir="$plugin_dir/$ptype"
        [[ ! -d "$type_dir" ]] && continue

        local has_plugins=false
        for f in "$type_dir"/*.yml; do
            [[ ! -f "$f" ]] && continue
            has_plugins=true
            local name desc
            name=$("$YQ" eval '.name // ""' "$f")
            desc=$("$YQ" eval '.desc // ""' "$f")
            printf "  ${GREEN}%-20s${NC} ${CYAN}[%s]${NC} %s\n" "$name" "$ptype" "$desc"
        done
    done
}

# plugin show - 显示插件详情
cmd_plugin_show() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez plugin show <name>"

    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    # 在各类型目录中搜索
    local plugin_file=""
    for ptype in param hook template; do
        local f="$plugin_dir/$ptype/$name.yml"
        if [[ -f "$f" ]]; then
            plugin_file="$f"
            break
        fi
    done

    [[ -z "$plugin_file" ]] && die "插件未找到: $name"

    local pname ptype pdesc pversion
    pname=$("$YQ" eval '.name // ""' "$plugin_file")
    ptype=$("$YQ" eval '.type // ""' "$plugin_file")
    pdesc=$("$YQ" eval '.desc // ""' "$plugin_file")
    pversion=$("$YQ" eval '.version // ""' "$plugin_file")

    echo -e "${BOLD}Plugin: ${GREEN}$pname${NC}"
    echo -e "${BOLD}Type:${NC} $ptype"
    echo -e "${BOLD}Version:${NC} $pversion"
    echo ""
    echo -e "${BOLD}Description:${NC} $pdesc"
    echo ""
    echo -e "${BOLD}Script:${NC}"
    "$YQ" eval '.script' "$plugin_file" | sed 's/^/  /'
}

# plugin run - 运行插件脚本
cmd_plugin_run() {
    local name="${1:-}"
    [[ -z "$name" ]] && die "用法: ez plugin run <name>"

    local plugin_dir
    plugin_dir=$(find_plugin_dir) || die "未找到插件目录"

    local plugin_file=""
    for ptype in param hook template; do
        local f="$plugin_dir/$ptype/$name.yml"
        if [[ -f "$f" ]]; then
            plugin_file="$f"
            break
        fi
    done

    [[ -z "$plugin_file" ]] && die "插件未找到: $name"

    local script
    script=$("$YQ" eval '.script' "$plugin_file")
    eval "$script"
}

# plugin install - 从 URL 安装插件
cmd_plugin_install() {
    local url="${1:-}"
    [[ -z "$url" ]] && die "用法: ez plugin install <url>"

    local plugin_dir="$HOME/.ez/plugins"
    mkdir -p "$plugin_dir"/{param,hook,template}

    # 下载插件
    local tmp_file
    tmp_file=$(mktemp)
    echo "Downloading from $url..."
    if ! curl -sSL "$url" -o "$tmp_file"; then
        rm -f "$tmp_file"
        die "下载失败: $url"
    fi

    # 解析插件类型和名称
    local pname ptype
    pname=$("$YQ" eval '.name // ""' "$tmp_file")
    ptype=$("$YQ" eval '.type // ""' "$tmp_file")

    [[ -z "$pname" ]] && { rm -f "$tmp_file"; die "无效的插件文件: 缺少 name"; }
    [[ -z "$ptype" ]] && { rm -f "$tmp_file"; die "无效的插件文件: 缺少 type"; }

    local target_file="$plugin_dir/$ptype/$pname.yml"
    mv "$tmp_file" "$target_file"

    echo -e "${GREEN}✓ 插件已安装: $pname ($ptype)${NC}"
    echo "  位置: $target_file"
}

# plugin 命令路由
cmd_plugin() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list|ls)    cmd_plugin_list "$@" ;;
        show)       cmd_plugin_show "$@" ;;
        run)        cmd_plugin_run "$@" ;;
        install)    cmd_plugin_install "$@" ;;
        *)          die "未知 plugin 子命令: $subcmd" ;;
    esac
}

# -----------------------------------------------------------------------------
# 主入口
# -----------------------------------------------------------------------------
main() {
    check_deps

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        list|ls)      cmd_list "$@" ;;
        show|info)    cmd_show "$@" ;;
        run|exec)     cmd_run "$@" ;;
        plan)         cmd_plan "$@" ;;
        template|tpl) cmd_template "$@" ;;
        plugin)       cmd_plugin "$@" ;;
        version|-v|--version)   cmd_version ;;
        help|-h|--help)         cmd_help ;;
        *)            die "未知命令: $cmd，运行 'ez help' 查看帮助" ;;
    esac
}

main "$@"
